#[cfg(not(target_arch = "bpf"))]
use {
    rand_core::{OsRng},
    crate::encryption::{
        elgamal::{ElGamalKeypair},
        pedersen::{PedersenOpening},
    },
};
use {
    arrayref::{array_ref, array_refs},
    borsh::{BorshSerialize, BorshDeserialize},
    bytemuck::{Pod, Zeroable},
    curve25519_dalek::{
        ristretto::{CompressedRistretto, RistrettoPoint},
        scalar::Scalar,
        traits::{IsIdentity, MultiscalarMul},
    },
    crate::{
        errors::ProofError,
        transcript::TranscriptProtocol,
    },
    crate::encryption::{
        elgamal::{ElGamalCiphertext, ElGamalPubkey},
        pedersen::{PedersenBase},
    },
    merlin::Transcript,
    solana_program::msg,
    std::convert::TryFrom,
};

#[allow(non_snake_case)]
#[derive(Clone)]
pub struct EqualityProof {
    pub Y_0: CompressedRistretto,
    pub Y_1: CompressedRistretto,
    pub Y_2: CompressedRistretto,
    pub sh_1: Scalar,
    pub rh_2: Scalar,
}

#[allow(non_snake_case)]
impl EqualityProof {
    #[cfg(not(target_arch = "bpf"))]
    pub fn new(
        src_keypair: &ElGamalKeypair,
        dst_pubkey: &ElGamalPubkey,
        src_ciphertext: &ElGamalCiphertext,
        dst_opening: &PedersenOpening,
        transcript: &mut Transcript,
    ) -> Self {
        // extract the relevant scalar and Ristretto points from the inputs
        let H = PedersenBase::default().H;

        let P1_EG = src_keypair.public.get_point();
        let P2_EG = dst_pubkey.get_point();
        let D1_EG = src_ciphertext.decrypt_handle.get_point();

        let s_1 = src_keypair.secret.get_scalar();
        let r_2 = dst_opening.get_scalar();

        // generate random masking factors that also serves as a nonce
        let b_1 = Scalar::random(&mut OsRng);
        let b_2 = Scalar::random(&mut OsRng);

        let Y_0 = (b_1 * P1_EG).compress();
        let Y_1 = (b_2 * P2_EG).compress();
        let Y_2 = RistrettoPoint::multiscalar_mul(vec![b_1, -b_2], vec![D1_EG, H]).compress();

        // record masking factors in transcript
        transcript.append_point(b"Y_0", &Y_0);
        transcript.append_point(b"Y_1", &Y_1);
        transcript.append_point(b"Y_2", &Y_2);

        let c = transcript.challenge_scalar(b"c");
        transcript.challenge_scalar(b"w");

        // compute the masked values
        let sh_1 = c * s_1 + b_1;
        let rh_2 = c * r_2 + b_2;

        EqualityProof {
            Y_0,
            Y_1,
            Y_2,
            sh_1,
            rh_2,
        }
    }

    pub fn build_transcript(
        equality_proof: &EqualityProof,
        transcript: &mut Transcript,
    ) -> Result<(), ProofError> {
        // include Y_0, Y_1, Y_2 to transcript and extract challenges
        transcript.validate_and_append_point(b"Y_0", &equality_proof.Y_0)?;
        transcript.validate_and_append_point(b"Y_1", &equality_proof.Y_1)?;
        transcript.validate_and_append_point(b"Y_2", &equality_proof.Y_2)?;

        Ok(())
    }

    pub fn verify(
        self,
        src_pubkey: &ElGamalPubkey,
        dst_pubkey: &ElGamalPubkey,
        src_ciphertext: &ElGamalCiphertext,
        dst_ciphertext: &ElGamalCiphertext,
        transcript: &mut Transcript,
    ) -> Result<(), ProofError> {
        // extract the relevant scalar and Ristretto points from the inputs
        let H = PedersenBase::default().H;

        EqualityProof::build_transcript(&self, transcript)?;

        let P1_EG = src_pubkey.get_point();
        let P2_EG = dst_pubkey.get_point();
        let C1_EG = src_ciphertext.message_comm.get_point();
        let D1_EG = src_ciphertext.decrypt_handle.get_point();
        let C2_EG = dst_ciphertext.message_comm.get_point();
        let D2_EG = dst_ciphertext.decrypt_handle.get_point();

        msg!("Getting challenge scalars");
        let c = transcript.challenge_scalar(b"c");
        let w = transcript.challenge_scalar(b"w");
        let ww = w * w;

        // check that the required algebraic condition holds
        let Y_0 = self.Y_0.decompress().ok_or(ProofError::VerificationError)?;
        let Y_1 = self.Y_1.decompress().ok_or(ProofError::VerificationError)?;
        let Y_2 = self.Y_2.decompress().ok_or(ProofError::VerificationError)?;

        msg!("Proving challenge succeeds");
        let check = RistrettoPoint::multiscalar_mul(
            vec![
                // that s_1 is the secret key for P1_EG
                self.sh_1,
                -c,
                -Scalar::one(),

                // that r_2 is the randomness used in D2_EG
                w * self.rh_2,
                -w * c,
                -w,

                // that the messages in C1_EG and C2_EG are equal under s_1 and r_2
                ww * c,
                -ww * c,
                ww * self.sh_1,
                -ww * self.rh_2,
                -ww,
            ],
            vec![
                P1_EG, H, Y_0,
                P2_EG, D2_EG, Y_1,
                C2_EG, C1_EG, D1_EG, H, Y_2,
            ],
        );

        if check.is_identity() {
            Ok(())
        } else {
            Err(ProofError::VerificationError)
        }
    }

    pub fn to_bytes(&self) -> [u8; 160] {
        let mut buf = [0_u8; 160];
        buf[..32].copy_from_slice(self.Y_0.as_bytes());
        buf[32..64].copy_from_slice(self.Y_1.as_bytes());
        buf[64..96].copy_from_slice(self.Y_2.as_bytes());
        buf[96..128].copy_from_slice(self.sh_1.as_bytes());
        buf[128..160].copy_from_slice(self.rh_2.as_bytes());
        buf
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ProofError> {
        let bytes = array_ref![bytes, 0, 160];
        let (Y_0, Y_1, Y_2, sh_1, rh_2) = array_refs![bytes, 32, 32, 32, 32, 32];

        let Y_0 = CompressedRistretto::from_slice(Y_0);
        let Y_1 = CompressedRistretto::from_slice(Y_1);
        let Y_2 = CompressedRistretto::from_slice(Y_2);

        let sh_1 = Scalar::from_canonical_bytes(*sh_1).ok_or(ProofError::FormatError)?;
        let rh_2 = Scalar::from_canonical_bytes(*rh_2).ok_or(ProofError::FormatError)?;

        Ok(EqualityProof {
            Y_0,
            Y_1,
            Y_2,
            sh_1,
            rh_2,
        })
    }
}

#[derive(Clone, Copy)]
#[repr(transparent)]
pub struct PodEqualityProof(pub [u8; 160]);
const POD_EQUALITY_PROOF_SIZE: usize = std::mem::size_of::<PodEqualityProof>();

impl BorshDeserialize for PodEqualityProof {
    fn deserialize(buf: &mut &[u8]) -> borsh::maybestd::io::Result<Self> {
        if buf.len() < POD_EQUALITY_PROOF_SIZE {
            return Err(borsh::maybestd::io::Error::new(
                borsh::maybestd::io::ErrorKind::InvalidInput,
                "Input too short for PodEqualityProof",
            ));
        }
        let mut res = [0; POD_EQUALITY_PROOF_SIZE];
        res.copy_from_slice(&buf[..POD_EQUALITY_PROOF_SIZE]);
        *buf = &buf[POD_EQUALITY_PROOF_SIZE..];
        Ok(PodEqualityProof(res))
    }
}

impl BorshSerialize for PodEqualityProof {
    fn serialize<W: borsh::maybestd::io::Write>(
        &self, writer: &mut W
    ) -> borsh::maybestd::io::Result<()> {
        writer.write_all(&self.0)
    }
}


// `EqualityProof` is a Pod and Zeroable.
// Add the marker traits manually because `bytemuck` only adds them for some `u8` arrays
unsafe impl Zeroable for PodEqualityProof {}
unsafe impl Pod for PodEqualityProof {}

impl From<EqualityProof> for PodEqualityProof {
    fn from(proof: EqualityProof) -> Self {
        Self(proof.to_bytes())
    }
}

impl TryFrom<PodEqualityProof> for EqualityProof {
    type Error = ProofError;

    fn try_from(pod: PodEqualityProof) -> Result<Self, Self::Error> {
        Self::from_bytes(&pod.0)
    }
}

pub const COMPRESSED_H: [u8; 32] = [
    140 , 146 , 64  , 180 , 86  , 169 , 230 , 220 ,
    101 , 195 , 119 , 161 , 4   , 141 , 116 , 95  ,
    148 , 160 , 140 , 219 , 127 , 68  , 203 , 205 ,
    123 , 70  , 243 , 64  , 72  , 135 , 17  , 52  ,
];

pub const DSL_INSTRUCTION_COUNT: usize = 154;
pub const DSL_INSTRUCTION_BYTES: [u8; DSL_INSTRUCTION_COUNT * 16] =
[
    0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xA0, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0xE0, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xE0, 0x01, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x60, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x3F, 0x40, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x3E, 0x3F, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x3D, 0x3E, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x3C, 0x3D, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x3B, 0x3C, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x3A, 0x3B, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x39, 0x3A, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x38, 0x39, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x37, 0x38, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x36, 0x37, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x35, 0x36, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x34, 0x35, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x33, 0x34, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x32, 0x33, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x31, 0x32, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x30, 0x31, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x2F, 0x30, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x2E, 0x2F, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x2D, 0x2E, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x2C, 0x2D, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x2B, 0x2C, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x2A, 0x2B, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x29, 0x2A, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x28, 0x29, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x27, 0x28, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x26, 0x27, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x25, 0x26, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x24, 0x25, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x23, 0x24, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x22, 0x23, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x21, 0x22, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x20, 0x21, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x1F, 0x20, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x1E, 0x1F, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x1D, 0x1E, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x1C, 0x1D, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x1B, 0x1C, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x1A, 0x1B, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x19, 0x1A, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x18, 0x19, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x17, 0x18, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x16, 0x17, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x15, 0x16, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x14, 0x15, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x13, 0x14, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x12, 0x13, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x11, 0x12, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x10, 0x11, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x0F, 0x10, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x0E, 0x0F, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x0D, 0x0E, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x0C, 0x0D, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x0B, 0x0C, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x0A, 0x0B, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x09, 0x0A, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x08, 0x09, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x07, 0x08, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x06, 0x07, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x05, 0x06, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x04, 0x05, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x03, 0x04, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x02, 0x03, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x01, 0x02, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x01, 0x0B, 0x80, 0x02, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
];

#[cfg(test)]
mod test {
    use super::*;
    use crate::encryption::pedersen::Pedersen;

    #[test]
    fn successful_equality_proof() {
        // success case
        let src_keypair = ElGamalKeypair::default();
        let dst_pubkey = ElGamalKeypair::default().public;
        let message: u64 = 55;

        let src_ciphertext = src_keypair.public.encrypt(message);

        let (dst_comm, dst_opening) = Pedersen::new(message);
        let dst_handle = dst_pubkey.decrypt_handle(&dst_opening);
        let dst_ciphertext = ElGamalCiphertext {
            message_comm: dst_comm,
            decrypt_handle: dst_handle,
        };

        let mut transcript_prover = Transcript::new(b"Test");
        let mut transcript_verifier = Transcript::new(b"Test");

        let proof = EqualityProof::new(
            &src_keypair,
            &dst_pubkey,
            &src_ciphertext,
            &dst_opening,
            &mut transcript_prover,
        );

        assert!(proof
            .verify(
                &src_keypair.public,
                &dst_pubkey,
                &src_ciphertext,
                &dst_ciphertext,
                &mut transcript_verifier
            )
            .is_ok());
    }

    #[test]
    fn invalid_equality_proof() {
        // failure case
        let src_keypair = ElGamalKeypair::default();
        let dst_pubkey = ElGamalKeypair::default().public;
        let src_message: u64 = 55;
        let dst_message: u64 = 56;

        let src_ciphertext = src_keypair.public.encrypt(src_message);

        let (dst_comm, dst_opening) = Pedersen::new(dst_message);
        let dst_handle = dst_pubkey.decrypt_handle(&dst_opening);
        let dst_ciphertext = ElGamalCiphertext {
            message_comm: dst_comm,
            decrypt_handle: dst_handle,
        };

        let mut transcript_prover = Transcript::new(b"Test");
        let mut transcript_verifier = Transcript::new(b"Test");

        let proof = EqualityProof::new(
            &src_keypair,
            &dst_pubkey,
            &src_ciphertext,
            &dst_opening,
            &mut transcript_prover,
        );

        assert!(proof
            .verify(
                &src_keypair.public,
                &dst_pubkey,
                &src_ciphertext,
                &dst_ciphertext,
                &mut transcript_verifier
            )
            .is_err());
    }
}
