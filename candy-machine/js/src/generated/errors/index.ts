/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number };
type MaybeErrorWithCode = ErrorWithCode | null | undefined;

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map();
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map();

/**
 * IncorrectOwner: 'Account does not have correct owner!'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectOwnerError extends Error {
  readonly code: number = 0x1770;
  readonly name: string = 'IncorrectOwner';
  constructor() {
    super('Account does not have correct owner!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectOwnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());

/**
 * Uninitialized: 'Account is not initialized!'
 *
 * @category Errors
 * @category generated
 */
export class UninitializedError extends Error {
  readonly code: number = 0x1771;
  readonly name: string = 'Uninitialized';
  constructor() {
    super('Account is not initialized!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UninitializedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new UninitializedError());
createErrorFromNameLookup.set('Uninitialized', () => new UninitializedError());

/**
 * MintMismatch: 'Mint Mismatch!'
 *
 * @category Errors
 * @category generated
 */
export class MintMismatchError extends Error {
  readonly code: number = 0x1772;
  readonly name: string = 'MintMismatch';
  constructor() {
    super('Mint Mismatch!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MintMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x1772, () => new MintMismatchError());
createErrorFromNameLookup.set('MintMismatch', () => new MintMismatchError());

/**
 * IndexGreaterThanLength: 'Index greater than length!'
 *
 * @category Errors
 * @category generated
 */
export class IndexGreaterThanLengthError extends Error {
  readonly code: number = 0x1773;
  readonly name: string = 'IndexGreaterThanLength';
  constructor() {
    super('Index greater than length!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IndexGreaterThanLengthError);
    }
  }
}

createErrorFromCodeLookup.set(0x1773, () => new IndexGreaterThanLengthError());
createErrorFromNameLookup.set('IndexGreaterThanLength', () => new IndexGreaterThanLengthError());

/**
 * NumericalOverflowError: 'Numerical overflow error!'
 *
 * @category Errors
 * @category generated
 */
export class NumericalOverflowErrorError extends Error {
  readonly code: number = 0x1774;
  readonly name: string = 'NumericalOverflowError';
  constructor() {
    super('Numerical overflow error!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NumericalOverflowErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new NumericalOverflowErrorError());
createErrorFromNameLookup.set('NumericalOverflowError', () => new NumericalOverflowErrorError());

/**
 * TooManyCreators: 'Can only provide up to 4 creators to candy machine (because candy machine is one)!'
 *
 * @category Errors
 * @category generated
 */
export class TooManyCreatorsError extends Error {
  readonly code: number = 0x1775;
  readonly name: string = 'TooManyCreators';
  constructor() {
    super('Can only provide up to 4 creators to candy machine (because candy machine is one)!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TooManyCreatorsError);
    }
  }
}

createErrorFromCodeLookup.set(0x1775, () => new TooManyCreatorsError());
createErrorFromNameLookup.set('TooManyCreators', () => new TooManyCreatorsError());

/**
 * UuidMustBeExactly6Length: 'Uuid must be exactly of 6 length'
 *
 * @category Errors
 * @category generated
 */
export class UuidMustBeExactly6LengthError extends Error {
  readonly code: number = 0x1776;
  readonly name: string = 'UuidMustBeExactly6Length';
  constructor() {
    super('Uuid must be exactly of 6 length');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UuidMustBeExactly6LengthError);
    }
  }
}

createErrorFromCodeLookup.set(0x1776, () => new UuidMustBeExactly6LengthError());
createErrorFromNameLookup.set(
  'UuidMustBeExactly6Length',
  () => new UuidMustBeExactly6LengthError(),
);

/**
 * NotEnoughTokens: 'Not enough tokens to pay for this minting'
 *
 * @category Errors
 * @category generated
 */
export class NotEnoughTokensError extends Error {
  readonly code: number = 0x1777;
  readonly name: string = 'NotEnoughTokens';
  constructor() {
    super('Not enough tokens to pay for this minting');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotEnoughTokensError);
    }
  }
}

createErrorFromCodeLookup.set(0x1777, () => new NotEnoughTokensError());
createErrorFromNameLookup.set('NotEnoughTokens', () => new NotEnoughTokensError());

/**
 * NotEnoughSOL: 'Not enough SOL to pay for this minting'
 *
 * @category Errors
 * @category generated
 */
export class NotEnoughSOLError extends Error {
  readonly code: number = 0x1778;
  readonly name: string = 'NotEnoughSOL';
  constructor() {
    super('Not enough SOL to pay for this minting');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotEnoughSOLError);
    }
  }
}

createErrorFromCodeLookup.set(0x1778, () => new NotEnoughSOLError());
createErrorFromNameLookup.set('NotEnoughSOL', () => new NotEnoughSOLError());

/**
 * TokenTransferFailed: 'Token transfer failed'
 *
 * @category Errors
 * @category generated
 */
export class TokenTransferFailedError extends Error {
  readonly code: number = 0x1779;
  readonly name: string = 'TokenTransferFailed';
  constructor() {
    super('Token transfer failed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenTransferFailedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1779, () => new TokenTransferFailedError());
createErrorFromNameLookup.set('TokenTransferFailed', () => new TokenTransferFailedError());

/**
 * CandyMachineEmpty: 'Candy machine is empty!'
 *
 * @category Errors
 * @category generated
 */
export class CandyMachineEmptyError extends Error {
  readonly code: number = 0x177a;
  readonly name: string = 'CandyMachineEmpty';
  constructor() {
    super('Candy machine is empty!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CandyMachineEmptyError);
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new CandyMachineEmptyError());
createErrorFromNameLookup.set('CandyMachineEmpty', () => new CandyMachineEmptyError());

/**
 * CandyMachineNotLive: 'Candy machine is not live!'
 *
 * @category Errors
 * @category generated
 */
export class CandyMachineNotLiveError extends Error {
  readonly code: number = 0x177b;
  readonly name: string = 'CandyMachineNotLive';
  constructor() {
    super('Candy machine is not live!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CandyMachineNotLiveError);
    }
  }
}

createErrorFromCodeLookup.set(0x177b, () => new CandyMachineNotLiveError());
createErrorFromNameLookup.set('CandyMachineNotLive', () => new CandyMachineNotLiveError());

/**
 * HiddenSettingsConfigsDoNotHaveConfigLines: 'Configs that are using hidden uris do not have config lines, they have a single hash representing hashed order'
 *
 * @category Errors
 * @category generated
 */
export class HiddenSettingsConfigsDoNotHaveConfigLinesError extends Error {
  readonly code: number = 0x177c;
  readonly name: string = 'HiddenSettingsConfigsDoNotHaveConfigLines';
  constructor() {
    super(
      'Configs that are using hidden uris do not have config lines, they have a single hash representing hashed order',
    );
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, HiddenSettingsConfigsDoNotHaveConfigLinesError);
    }
  }
}

createErrorFromCodeLookup.set(0x177c, () => new HiddenSettingsConfigsDoNotHaveConfigLinesError());
createErrorFromNameLookup.set(
  'HiddenSettingsConfigsDoNotHaveConfigLines',
  () => new HiddenSettingsConfigsDoNotHaveConfigLinesError(),
);

/**
 * CannotChangeNumberOfLines: 'Cannot change number of lines unless is a hidden config'
 *
 * @category Errors
 * @category generated
 */
export class CannotChangeNumberOfLinesError extends Error {
  readonly code: number = 0x177d;
  readonly name: string = 'CannotChangeNumberOfLines';
  constructor() {
    super('Cannot change number of lines unless is a hidden config');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotChangeNumberOfLinesError);
    }
  }
}

createErrorFromCodeLookup.set(0x177d, () => new CannotChangeNumberOfLinesError());
createErrorFromNameLookup.set(
  'CannotChangeNumberOfLines',
  () => new CannotChangeNumberOfLinesError(),
);

/**
 * DerivedKeyInvalid: 'Derived key invalid'
 *
 * @category Errors
 * @category generated
 */
export class DerivedKeyInvalidError extends Error {
  readonly code: number = 0x177e;
  readonly name: string = 'DerivedKeyInvalid';
  constructor() {
    super('Derived key invalid');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DerivedKeyInvalidError);
    }
  }
}

createErrorFromCodeLookup.set(0x177e, () => new DerivedKeyInvalidError());
createErrorFromNameLookup.set('DerivedKeyInvalid', () => new DerivedKeyInvalidError());

/**
 * PublicKeyMismatch: 'Public key mismatch'
 *
 * @category Errors
 * @category generated
 */
export class PublicKeyMismatchError extends Error {
  readonly code: number = 0x177f;
  readonly name: string = 'PublicKeyMismatch';
  constructor() {
    super('Public key mismatch');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PublicKeyMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x177f, () => new PublicKeyMismatchError());
createErrorFromNameLookup.set('PublicKeyMismatch', () => new PublicKeyMismatchError());

/**
 * NoWhitelistToken: 'No whitelist token present'
 *
 * @category Errors
 * @category generated
 */
export class NoWhitelistTokenError extends Error {
  readonly code: number = 0x1780;
  readonly name: string = 'NoWhitelistToken';
  constructor() {
    super('No whitelist token present');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoWhitelistTokenError);
    }
  }
}

createErrorFromCodeLookup.set(0x1780, () => new NoWhitelistTokenError());
createErrorFromNameLookup.set('NoWhitelistToken', () => new NoWhitelistTokenError());

/**
 * TokenBurnFailed: 'Token burn failed'
 *
 * @category Errors
 * @category generated
 */
export class TokenBurnFailedError extends Error {
  readonly code: number = 0x1781;
  readonly name: string = 'TokenBurnFailed';
  constructor() {
    super('Token burn failed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenBurnFailedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1781, () => new TokenBurnFailedError());
createErrorFromNameLookup.set('TokenBurnFailed', () => new TokenBurnFailedError());

/**
 * GatewayAppMissing: 'Missing gateway app when required'
 *
 * @category Errors
 * @category generated
 */
export class GatewayAppMissingError extends Error {
  readonly code: number = 0x1782;
  readonly name: string = 'GatewayAppMissing';
  constructor() {
    super('Missing gateway app when required');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, GatewayAppMissingError);
    }
  }
}

createErrorFromCodeLookup.set(0x1782, () => new GatewayAppMissingError());
createErrorFromNameLookup.set('GatewayAppMissing', () => new GatewayAppMissingError());

/**
 * GatewayTokenMissing: 'Missing gateway token when required'
 *
 * @category Errors
 * @category generated
 */
export class GatewayTokenMissingError extends Error {
  readonly code: number = 0x1783;
  readonly name: string = 'GatewayTokenMissing';
  constructor() {
    super('Missing gateway token when required');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, GatewayTokenMissingError);
    }
  }
}

createErrorFromCodeLookup.set(0x1783, () => new GatewayTokenMissingError());
createErrorFromNameLookup.set('GatewayTokenMissing', () => new GatewayTokenMissingError());

/**
 * GatewayTokenExpireTimeInvalid: 'Invalid gateway token expire time'
 *
 * @category Errors
 * @category generated
 */
export class GatewayTokenExpireTimeInvalidError extends Error {
  readonly code: number = 0x1784;
  readonly name: string = 'GatewayTokenExpireTimeInvalid';
  constructor() {
    super('Invalid gateway token expire time');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, GatewayTokenExpireTimeInvalidError);
    }
  }
}

createErrorFromCodeLookup.set(0x1784, () => new GatewayTokenExpireTimeInvalidError());
createErrorFromNameLookup.set(
  'GatewayTokenExpireTimeInvalid',
  () => new GatewayTokenExpireTimeInvalidError(),
);

/**
 * NetworkExpireFeatureMissing: 'Missing gateway network expire feature when required'
 *
 * @category Errors
 * @category generated
 */
export class NetworkExpireFeatureMissingError extends Error {
  readonly code: number = 0x1785;
  readonly name: string = 'NetworkExpireFeatureMissing';
  constructor() {
    super('Missing gateway network expire feature when required');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NetworkExpireFeatureMissingError);
    }
  }
}

createErrorFromCodeLookup.set(0x1785, () => new NetworkExpireFeatureMissingError());
createErrorFromNameLookup.set(
  'NetworkExpireFeatureMissing',
  () => new NetworkExpireFeatureMissingError(),
);

/**
 * CannotFindUsableConfigLine: 'Unable to find an unused config line near your random number index'
 *
 * @category Errors
 * @category generated
 */
export class CannotFindUsableConfigLineError extends Error {
  readonly code: number = 0x1786;
  readonly name: string = 'CannotFindUsableConfigLine';
  constructor() {
    super('Unable to find an unused config line near your random number index');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotFindUsableConfigLineError);
    }
  }
}

createErrorFromCodeLookup.set(0x1786, () => new CannotFindUsableConfigLineError());
createErrorFromNameLookup.set(
  'CannotFindUsableConfigLine',
  () => new CannotFindUsableConfigLineError(),
);

/**
 * InvalidString: 'Invalid string'
 *
 * @category Errors
 * @category generated
 */
export class InvalidStringError extends Error {
  readonly code: number = 0x1787;
  readonly name: string = 'InvalidString';
  constructor() {
    super('Invalid string');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidStringError);
    }
  }
}

createErrorFromCodeLookup.set(0x1787, () => new InvalidStringError());
createErrorFromNameLookup.set('InvalidString', () => new InvalidStringError());

/**
 * SuspiciousTransaction: 'Suspicious transaction detected'
 *
 * @category Errors
 * @category generated
 */
export class SuspiciousTransactionError extends Error {
  readonly code: number = 0x1788;
  readonly name: string = 'SuspiciousTransaction';
  constructor() {
    super('Suspicious transaction detected');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, SuspiciousTransactionError);
    }
  }
}

createErrorFromCodeLookup.set(0x1788, () => new SuspiciousTransactionError());
createErrorFromNameLookup.set('SuspiciousTransaction', () => new SuspiciousTransactionError());

/**
 * CannotSwitchToHiddenSettings: 'Cannot Switch to Hidden Settings after items available is greater than 0'
 *
 * @category Errors
 * @category generated
 */
export class CannotSwitchToHiddenSettingsError extends Error {
  readonly code: number = 0x1789;
  readonly name: string = 'CannotSwitchToHiddenSettings';
  constructor() {
    super('Cannot Switch to Hidden Settings after items available is greater than 0');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotSwitchToHiddenSettingsError);
    }
  }
}

createErrorFromCodeLookup.set(0x1789, () => new CannotSwitchToHiddenSettingsError());
createErrorFromNameLookup.set(
  'CannotSwitchToHiddenSettings',
  () => new CannotSwitchToHiddenSettingsError(),
);

/**
 * IncorrectSlotHashesPubkey: 'Incorrect SlotHashes PubKey'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectSlotHashesPubkeyError extends Error {
  readonly code: number = 0x178a;
  readonly name: string = 'IncorrectSlotHashesPubkey';
  constructor() {
    super('Incorrect SlotHashes PubKey');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectSlotHashesPubkeyError);
    }
  }
}

createErrorFromCodeLookup.set(0x178a, () => new IncorrectSlotHashesPubkeyError());
createErrorFromNameLookup.set(
  'IncorrectSlotHashesPubkey',
  () => new IncorrectSlotHashesPubkeyError(),
);

/**
 * IncorrectCollectionAuthority: 'Incorrect collection NFT authority'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectCollectionAuthorityError extends Error {
  readonly code: number = 0x178b;
  readonly name: string = 'IncorrectCollectionAuthority';
  constructor() {
    super('Incorrect collection NFT authority');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectCollectionAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0x178b, () => new IncorrectCollectionAuthorityError());
createErrorFromNameLookup.set(
  'IncorrectCollectionAuthority',
  () => new IncorrectCollectionAuthorityError(),
);

/**
 * MismatchedCollectionPDA: 'Collection PDA address is invalid'
 *
 * @category Errors
 * @category generated
 */
export class MismatchedCollectionPDAError extends Error {
  readonly code: number = 0x178c;
  readonly name: string = 'MismatchedCollectionPDA';
  constructor() {
    super('Collection PDA address is invalid');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MismatchedCollectionPDAError);
    }
  }
}

createErrorFromCodeLookup.set(0x178c, () => new MismatchedCollectionPDAError());
createErrorFromNameLookup.set('MismatchedCollectionPDA', () => new MismatchedCollectionPDAError());

/**
 * MismatchedCollectionMint: 'Provided mint account doesn't match collection PDA mint'
 *
 * @category Errors
 * @category generated
 */
export class MismatchedCollectionMintError extends Error {
  readonly code: number = 0x178d;
  readonly name: string = 'MismatchedCollectionMint';
  constructor() {
    super("Provided mint account doesn't match collection PDA mint");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MismatchedCollectionMintError);
    }
  }
}

createErrorFromCodeLookup.set(0x178d, () => new MismatchedCollectionMintError());
createErrorFromNameLookup.set(
  'MismatchedCollectionMint',
  () => new MismatchedCollectionMintError(),
);

/**
 * SlotHashesEmpty: 'Slot hashes Sysvar is empty'
 *
 * @category Errors
 * @category generated
 */
export class SlotHashesEmptyError extends Error {
  readonly code: number = 0x178e;
  readonly name: string = 'SlotHashesEmpty';
  constructor() {
    super('Slot hashes Sysvar is empty');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, SlotHashesEmptyError);
    }
  }
}

createErrorFromCodeLookup.set(0x178e, () => new SlotHashesEmptyError());
createErrorFromNameLookup.set('SlotHashesEmpty', () => new SlotHashesEmptyError());

/**
 * MetadataAccountMustBeEmpty: 'The metadata account has data in it, and this must be empty to mint a new NFT'
 *
 * @category Errors
 * @category generated
 */
export class MetadataAccountMustBeEmptyError extends Error {
  readonly code: number = 0x178f;
  readonly name: string = 'MetadataAccountMustBeEmpty';
  constructor() {
    super('The metadata account has data in it, and this must be empty to mint a new NFT');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MetadataAccountMustBeEmptyError);
    }
  }
}

createErrorFromCodeLookup.set(0x178f, () => new MetadataAccountMustBeEmptyError());
createErrorFromNameLookup.set(
  'MetadataAccountMustBeEmpty',
  () => new MetadataAccountMustBeEmptyError(),
);

/**
 * MissingSetCollectionDuringMint: 'Missing set collection during mint IX for Candy Machine with collection set'
 *
 * @category Errors
 * @category generated
 */
export class MissingSetCollectionDuringMintError extends Error {
  readonly code: number = 0x1790;
  readonly name: string = 'MissingSetCollectionDuringMint';
  constructor() {
    super('Missing set collection during mint IX for Candy Machine with collection set');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingSetCollectionDuringMintError);
    }
  }
}

createErrorFromCodeLookup.set(0x1790, () => new MissingSetCollectionDuringMintError());
createErrorFromNameLookup.set(
  'MissingSetCollectionDuringMint',
  () => new MissingSetCollectionDuringMintError(),
);

/**
 * NoChangingCollectionDuringMint: 'Can't change collection settings after items have begun to be minted'
 *
 * @category Errors
 * @category generated
 */
export class NoChangingCollectionDuringMintError extends Error {
  readonly code: number = 0x1791;
  readonly name: string = 'NoChangingCollectionDuringMint';
  constructor() {
    super("Can't change collection settings after items have begun to be minted");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoChangingCollectionDuringMintError);
    }
  }
}

createErrorFromCodeLookup.set(0x1791, () => new NoChangingCollectionDuringMintError());
createErrorFromNameLookup.set(
  'NoChangingCollectionDuringMint',
  () => new NoChangingCollectionDuringMintError(),
);

/**
 * CandyCollectionRequiresRetainAuthority: 'Retain authority must be true for Candy Machines with a collection set'
 *
 * @category Errors
 * @category generated
 */
export class CandyCollectionRequiresRetainAuthorityError extends Error {
  readonly code: number = 0x1792;
  readonly name: string = 'CandyCollectionRequiresRetainAuthority';
  constructor() {
    super('Retain authority must be true for Candy Machines with a collection set');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CandyCollectionRequiresRetainAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0x1792, () => new CandyCollectionRequiresRetainAuthorityError());
createErrorFromNameLookup.set(
  'CandyCollectionRequiresRetainAuthority',
  () => new CandyCollectionRequiresRetainAuthorityError(),
);

/**
 * GatewayProgramError: 'Error within Gateway program'
 *
 * @category Errors
 * @category generated
 */
export class GatewayProgramErrorError extends Error {
  readonly code: number = 0x1793;
  readonly name: string = 'GatewayProgramError';
  constructor() {
    super('Error within Gateway program');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, GatewayProgramErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x1793, () => new GatewayProgramErrorError());
createErrorFromNameLookup.set('GatewayProgramError', () => new GatewayProgramErrorError());

/**
 * NoChangingFreezeDuringMint: 'Can't change freeze settings after items have begun to be minted. You can only disable.'
 *
 * @category Errors
 * @category generated
 */
export class NoChangingFreezeDuringMintError extends Error {
  readonly code: number = 0x1794;
  readonly name: string = 'NoChangingFreezeDuringMint';
  constructor() {
    super(
      "Can't change freeze settings after items have begun to be minted. You can only disable.",
    );
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoChangingFreezeDuringMintError);
    }
  }
}

createErrorFromCodeLookup.set(0x1794, () => new NoChangingFreezeDuringMintError());
createErrorFromNameLookup.set(
  'NoChangingFreezeDuringMint',
  () => new NoChangingFreezeDuringMintError(),
);

/**
 * NoChangingAuthorityWithCollection: 'Can't change authority while collection is enabled. Disable collection first.'
 *
 * @category Errors
 * @category generated
 */
export class NoChangingAuthorityWithCollectionError extends Error {
  readonly code: number = 0x1795;
  readonly name: string = 'NoChangingAuthorityWithCollection';
  constructor() {
    super("Can't change authority while collection is enabled. Disable collection first.");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoChangingAuthorityWithCollectionError);
    }
  }
}

createErrorFromCodeLookup.set(0x1795, () => new NoChangingAuthorityWithCollectionError());
createErrorFromNameLookup.set(
  'NoChangingAuthorityWithCollection',
  () => new NoChangingAuthorityWithCollectionError(),
);

/**
 * NoChangingTokenWithFreeze: 'Can't change token while freeze is enabled. Disable freeze first.'
 *
 * @category Errors
 * @category generated
 */
export class NoChangingTokenWithFreezeError extends Error {
  readonly code: number = 0x1796;
  readonly name: string = 'NoChangingTokenWithFreeze';
  constructor() {
    super("Can't change token while freeze is enabled. Disable freeze first.");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoChangingTokenWithFreezeError);
    }
  }
}

createErrorFromCodeLookup.set(0x1796, () => new NoChangingTokenWithFreezeError());
createErrorFromNameLookup.set(
  'NoChangingTokenWithFreeze',
  () => new NoChangingTokenWithFreezeError(),
);

/**
 * InvalidThawNft: 'Cannot thaw NFT unless all NFTs are minted or Candy Machine authority enables thawing'
 *
 * @category Errors
 * @category generated
 */
export class InvalidThawNftError extends Error {
  readonly code: number = 0x1797;
  readonly name: string = 'InvalidThawNft';
  constructor() {
    super('Cannot thaw NFT unless all NFTs are minted or Candy Machine authority enables thawing');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidThawNftError);
    }
  }
}

createErrorFromCodeLookup.set(0x1797, () => new InvalidThawNftError());
createErrorFromNameLookup.set('InvalidThawNft', () => new InvalidThawNftError());

/**
 * IncorrectRemainingAccountsLen: 'The number of remaining accounts passed in doesn't match the Candy Machine settings'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectRemainingAccountsLenError extends Error {
  readonly code: number = 0x1798;
  readonly name: string = 'IncorrectRemainingAccountsLen';
  constructor() {
    super("The number of remaining accounts passed in doesn't match the Candy Machine settings");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectRemainingAccountsLenError);
    }
  }
}

createErrorFromCodeLookup.set(0x1798, () => new IncorrectRemainingAccountsLenError());
createErrorFromNameLookup.set(
  'IncorrectRemainingAccountsLen',
  () => new IncorrectRemainingAccountsLenError(),
);

/**
 * MissingFreezeAta: 'FreezePDA ATA needs to be passed in if token mint is enabled.'
 *
 * @category Errors
 * @category generated
 */
export class MissingFreezeAtaError extends Error {
  readonly code: number = 0x1799;
  readonly name: string = 'MissingFreezeAta';
  constructor() {
    super('FreezePDA ATA needs to be passed in if token mint is enabled.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingFreezeAtaError);
    }
  }
}

createErrorFromCodeLookup.set(0x1799, () => new MissingFreezeAtaError());
createErrorFromNameLookup.set('MissingFreezeAta', () => new MissingFreezeAtaError());

/**
 * IncorrectFreezeAta: 'Incorrect freeze ATA address.'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectFreezeAtaError extends Error {
  readonly code: number = 0x179a;
  readonly name: string = 'IncorrectFreezeAta';
  constructor() {
    super('Incorrect freeze ATA address.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectFreezeAtaError);
    }
  }
}

createErrorFromCodeLookup.set(0x179a, () => new IncorrectFreezeAtaError());
createErrorFromNameLookup.set('IncorrectFreezeAta', () => new IncorrectFreezeAtaError());

/**
 * FreezePDAMismatch: 'FreezePDA doesn't belong to this Candy Machine.'
 *
 * @category Errors
 * @category generated
 */
export class FreezePDAMismatchError extends Error {
  readonly code: number = 0x179b;
  readonly name: string = 'FreezePDAMismatch';
  constructor() {
    super("FreezePDA doesn't belong to this Candy Machine.");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, FreezePDAMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x179b, () => new FreezePDAMismatchError());
createErrorFromNameLookup.set('FreezePDAMismatch', () => new FreezePDAMismatchError());

/**
 * EnteredFreezeIsMoreThanMaxFreeze: 'Freeze time can't be longer than MAX_FREEZE_TIME.'
 *
 * @category Errors
 * @category generated
 */
export class EnteredFreezeIsMoreThanMaxFreezeError extends Error {
  readonly code: number = 0x179c;
  readonly name: string = 'EnteredFreezeIsMoreThanMaxFreeze';
  constructor() {
    super("Freeze time can't be longer than MAX_FREEZE_TIME.");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, EnteredFreezeIsMoreThanMaxFreezeError);
    }
  }
}

createErrorFromCodeLookup.set(0x179c, () => new EnteredFreezeIsMoreThanMaxFreezeError());
createErrorFromNameLookup.set(
  'EnteredFreezeIsMoreThanMaxFreeze',
  () => new EnteredFreezeIsMoreThanMaxFreezeError(),
);

/**
 * NoWithdrawWithFreeze: 'Can't withdraw Candy Machine while freeze is active. Disable freeze first.'
 *
 * @category Errors
 * @category generated
 */
export class NoWithdrawWithFreezeError extends Error {
  readonly code: number = 0x179d;
  readonly name: string = 'NoWithdrawWithFreeze';
  constructor() {
    super("Can't withdraw Candy Machine while freeze is active. Disable freeze first.");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoWithdrawWithFreezeError);
    }
  }
}

createErrorFromCodeLookup.set(0x179d, () => new NoWithdrawWithFreezeError());
createErrorFromNameLookup.set('NoWithdrawWithFreeze', () => new NoWithdrawWithFreezeError());

/**
 * NoWithdrawWithFrozenFunds: 'Can't withdraw Candy Machine while frozen funds need to be redeemed. Unlock funds first.'
 *
 * @category Errors
 * @category generated
 */
export class NoWithdrawWithFrozenFundsError extends Error {
  readonly code: number = 0x179e;
  readonly name: string = 'NoWithdrawWithFrozenFunds';
  constructor() {
    super(
      "Can't withdraw Candy Machine while frozen funds need to be redeemed. Unlock funds first.",
    );
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoWithdrawWithFrozenFundsError);
    }
  }
}

createErrorFromCodeLookup.set(0x179e, () => new NoWithdrawWithFrozenFundsError());
createErrorFromNameLookup.set(
  'NoWithdrawWithFrozenFunds',
  () => new NoWithdrawWithFrozenFundsError(),
);

/**
 * MissingRemoveFreezeTokenAccounts: 'Missing required remaining accounts for remove_freeze with token mint.'
 *
 * @category Errors
 * @category generated
 */
export class MissingRemoveFreezeTokenAccountsError extends Error {
  readonly code: number = 0x179f;
  readonly name: string = 'MissingRemoveFreezeTokenAccounts';
  constructor() {
    super('Missing required remaining accounts for remove_freeze with token mint.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingRemoveFreezeTokenAccountsError);
    }
  }
}

createErrorFromCodeLookup.set(0x179f, () => new MissingRemoveFreezeTokenAccountsError());
createErrorFromNameLookup.set(
  'MissingRemoveFreezeTokenAccounts',
  () => new MissingRemoveFreezeTokenAccountsError(),
);

/**
 * InvalidFreezeWithdrawTokenAddress: 'Can't withdraw SPL Token from freeze PDA into itself'
 *
 * @category Errors
 * @category generated
 */
export class InvalidFreezeWithdrawTokenAddressError extends Error {
  readonly code: number = 0x17a0;
  readonly name: string = 'InvalidFreezeWithdrawTokenAddress';
  constructor() {
    super("Can't withdraw SPL Token from freeze PDA into itself");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidFreezeWithdrawTokenAddressError);
    }
  }
}

createErrorFromCodeLookup.set(0x17a0, () => new InvalidFreezeWithdrawTokenAddressError());
createErrorFromNameLookup.set(
  'InvalidFreezeWithdrawTokenAddress',
  () => new InvalidFreezeWithdrawTokenAddressError(),
);

/**
 * NoUnlockWithNFTsStillFrozen: 'Can't unlock funds while NFTs are still frozen. Run thaw on all NFTs first.'
 *
 * @category Errors
 * @category generated
 */
export class NoUnlockWithNFTsStillFrozenError extends Error {
  readonly code: number = 0x17a1;
  readonly name: string = 'NoUnlockWithNFTsStillFrozen';
  constructor() {
    super("Can't unlock funds while NFTs are still frozen. Run thaw on all NFTs first.");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoUnlockWithNFTsStillFrozenError);
    }
  }
}

createErrorFromCodeLookup.set(0x17a1, () => new NoUnlockWithNFTsStillFrozenError());
createErrorFromNameLookup.set(
  'NoUnlockWithNFTsStillFrozen',
  () => new NoUnlockWithNFTsStillFrozenError(),
);

/**
 * SizedCollectionMetadataMustBeMutable: 'Setting a sized collection requires the collection metadata to be mutable.'
 *
 * @category Errors
 * @category generated
 */
export class SizedCollectionMetadataMustBeMutableError extends Error {
  readonly code: number = 0x17a2;
  readonly name: string = 'SizedCollectionMetadataMustBeMutable';
  constructor() {
    super('Setting a sized collection requires the collection metadata to be mutable.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, SizedCollectionMetadataMustBeMutableError);
    }
  }
}

createErrorFromCodeLookup.set(0x17a2, () => new SizedCollectionMetadataMustBeMutableError());
createErrorFromNameLookup.set(
  'SizedCollectionMetadataMustBeMutable',
  () => new SizedCollectionMetadataMustBeMutableError(),
);

/**
 * CannotSwitchFromHiddenSettings: 'Cannot remove Hidden Settings.'
 *
 * @category Errors
 * @category generated
 */
export class CannotSwitchFromHiddenSettingsError extends Error {
  readonly code: number = 0x17a3;
  readonly name: string = 'CannotSwitchFromHiddenSettings';
  constructor() {
    super('Cannot remove Hidden Settings.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotSwitchFromHiddenSettingsError);
    }
  }
}

createErrorFromCodeLookup.set(0x17a3, () => new CannotSwitchFromHiddenSettingsError());
createErrorFromNameLookup.set(
  'CannotSwitchFromHiddenSettings',
  () => new CannotSwitchFromHiddenSettingsError(),
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code);
  return createError != null ? createError() : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name);
  return createError != null ? createError() : null;
}
