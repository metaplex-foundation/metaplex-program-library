/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number };
type MaybeErrorWithCode = ErrorWithCode | null | undefined;

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map();
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map();

/**
 * InvalidAccountSize: 'Could not save guard to account'
 *
 * @category Errors
 * @category generated
 */
export class InvalidAccountSizeError extends Error {
  readonly code: number = 0x1770;
  readonly name: string = 'InvalidAccountSize';
  constructor() {
    super('Could not save guard to account');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidAccountSizeError);
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new InvalidAccountSizeError());
createErrorFromNameLookup.set('InvalidAccountSize', () => new InvalidAccountSizeError());

/**
 * DeserializationError: 'Could not deserialize guard'
 *
 * @category Errors
 * @category generated
 */
export class DeserializationErrorError extends Error {
  readonly code: number = 0x1771;
  readonly name: string = 'DeserializationError';
  constructor() {
    super('Could not deserialize guard');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DeserializationErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new DeserializationErrorError());
createErrorFromNameLookup.set('DeserializationError', () => new DeserializationErrorError());

/**
 * PublicKeyMismatch: 'Public key mismatch'
 *
 * @category Errors
 * @category generated
 */
export class PublicKeyMismatchError extends Error {
  readonly code: number = 0x1772;
  readonly name: string = 'PublicKeyMismatch';
  constructor() {
    super('Public key mismatch');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PublicKeyMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x1772, () => new PublicKeyMismatchError());
createErrorFromNameLookup.set('PublicKeyMismatch', () => new PublicKeyMismatchError());

/**
 * DataIncrementLimitExceeded: 'Missing expected remaining account'
 *
 * @category Errors
 * @category generated
 */
export class DataIncrementLimitExceededError extends Error {
  readonly code: number = 0x1773;
  readonly name: string = 'DataIncrementLimitExceeded';
  constructor() {
    super('Missing expected remaining account');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DataIncrementLimitExceededError);
    }
  }
}

createErrorFromCodeLookup.set(0x1773, () => new DataIncrementLimitExceededError());
createErrorFromNameLookup.set(
  'DataIncrementLimitExceeded',
  () => new DataIncrementLimitExceededError(),
);

/**
 * IncorrectOwner: 'Account does not have correct owner'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectOwnerError extends Error {
  readonly code: number = 0x1774;
  readonly name: string = 'IncorrectOwner';
  constructor() {
    super('Account does not have correct owner');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectOwnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());

/**
 * Uninitialized: 'Account is not initialized'
 *
 * @category Errors
 * @category generated
 */
export class UninitializedError extends Error {
  readonly code: number = 0x1775;
  readonly name: string = 'Uninitialized';
  constructor() {
    super('Account is not initialized');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UninitializedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1775, () => new UninitializedError());
createErrorFromNameLookup.set('Uninitialized', () => new UninitializedError());

/**
 * MissingRemainingAccount: 'Missing expected remaining account'
 *
 * @category Errors
 * @category generated
 */
export class MissingRemainingAccountError extends Error {
  readonly code: number = 0x1776;
  readonly name: string = 'MissingRemainingAccount';
  constructor() {
    super('Missing expected remaining account');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingRemainingAccountError);
    }
  }
}

createErrorFromCodeLookup.set(0x1776, () => new MissingRemainingAccountError());
createErrorFromNameLookup.set('MissingRemainingAccount', () => new MissingRemainingAccountError());

/**
 * NumericalOverflowError: 'Numerical overflow error'
 *
 * @category Errors
 * @category generated
 */
export class NumericalOverflowErrorError extends Error {
  readonly code: number = 0x1777;
  readonly name: string = 'NumericalOverflowError';
  constructor() {
    super('Numerical overflow error');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NumericalOverflowErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x1777, () => new NumericalOverflowErrorError());
createErrorFromNameLookup.set('NumericalOverflowError', () => new NumericalOverflowErrorError());

/**
 * CollectionKeyMismatch: 'Collection public key mismatch'
 *
 * @category Errors
 * @category generated
 */
export class CollectionKeyMismatchError extends Error {
  readonly code: number = 0x1778;
  readonly name: string = 'CollectionKeyMismatch';
  constructor() {
    super('Collection public key mismatch');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionKeyMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x1778, () => new CollectionKeyMismatchError());
createErrorFromNameLookup.set('CollectionKeyMismatch', () => new CollectionKeyMismatchError());

/**
 * MissingCollectionAccounts: 'Missing collection accounts'
 *
 * @category Errors
 * @category generated
 */
export class MissingCollectionAccountsError extends Error {
  readonly code: number = 0x1779;
  readonly name: string = 'MissingCollectionAccounts';
  constructor() {
    super('Missing collection accounts');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingCollectionAccountsError);
    }
  }
}

createErrorFromCodeLookup.set(0x1779, () => new MissingCollectionAccountsError());
createErrorFromNameLookup.set(
  'MissingCollectionAccounts',
  () => new MissingCollectionAccountsError(),
);

/**
 * CollectionUpdateAuthorityKeyMismatch: 'Collection update authority public key mismatch'
 *
 * @category Errors
 * @category generated
 */
export class CollectionUpdateAuthorityKeyMismatchError extends Error {
  readonly code: number = 0x177a;
  readonly name: string = 'CollectionUpdateAuthorityKeyMismatch';
  constructor() {
    super('Collection update authority public key mismatch');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionUpdateAuthorityKeyMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new CollectionUpdateAuthorityKeyMismatchError());
createErrorFromNameLookup.set(
  'CollectionUpdateAuthorityKeyMismatch',
  () => new CollectionUpdateAuthorityKeyMismatchError(),
);

/**
 * MintNotLastTransaction: 'Mint must be the last instructions of the transaction'
 *
 * @category Errors
 * @category generated
 */
export class MintNotLastTransactionError extends Error {
  readonly code: number = 0x177b;
  readonly name: string = 'MintNotLastTransaction';
  constructor() {
    super('Mint must be the last instructions of the transaction');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MintNotLastTransactionError);
    }
  }
}

createErrorFromCodeLookup.set(0x177b, () => new MintNotLastTransactionError());
createErrorFromNameLookup.set('MintNotLastTransaction', () => new MintNotLastTransactionError());

/**
 * MintNotLive: 'Mint is not live'
 *
 * @category Errors
 * @category generated
 */
export class MintNotLiveError extends Error {
  readonly code: number = 0x177c;
  readonly name: string = 'MintNotLive';
  constructor() {
    super('Mint is not live');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MintNotLiveError);
    }
  }
}

createErrorFromCodeLookup.set(0x177c, () => new MintNotLiveError());
createErrorFromNameLookup.set('MintNotLive', () => new MintNotLiveError());

/**
 * NotEnoughSOL: 'Not enough SOL to pay for the mint'
 *
 * @category Errors
 * @category generated
 */
export class NotEnoughSOLError extends Error {
  readonly code: number = 0x177d;
  readonly name: string = 'NotEnoughSOL';
  constructor() {
    super('Not enough SOL to pay for the mint');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotEnoughSOLError);
    }
  }
}

createErrorFromCodeLookup.set(0x177d, () => new NotEnoughSOLError());
createErrorFromNameLookup.set('NotEnoughSOL', () => new NotEnoughSOLError());

/**
 * TokenTransferFailed: 'Token transfer failed'
 *
 * @category Errors
 * @category generated
 */
export class TokenTransferFailedError extends Error {
  readonly code: number = 0x177e;
  readonly name: string = 'TokenTransferFailed';
  constructor() {
    super('Token transfer failed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenTransferFailedError);
    }
  }
}

createErrorFromCodeLookup.set(0x177e, () => new TokenTransferFailedError());
createErrorFromNameLookup.set('TokenTransferFailed', () => new TokenTransferFailedError());

/**
 * NotEnoughTokens: 'Not enough tokens to pay for this minting'
 *
 * @category Errors
 * @category generated
 */
export class NotEnoughTokensError extends Error {
  readonly code: number = 0x177f;
  readonly name: string = 'NotEnoughTokens';
  constructor() {
    super('Not enough tokens to pay for this minting');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotEnoughTokensError);
    }
  }
}

createErrorFromCodeLookup.set(0x177f, () => new NotEnoughTokensError());
createErrorFromNameLookup.set('NotEnoughTokens', () => new NotEnoughTokensError());

/**
 * MissingRequiredSignature: 'A signature was required but not found'
 *
 * @category Errors
 * @category generated
 */
export class MissingRequiredSignatureError extends Error {
  readonly code: number = 0x1780;
  readonly name: string = 'MissingRequiredSignature';
  constructor() {
    super('A signature was required but not found');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingRequiredSignatureError);
    }
  }
}

createErrorFromCodeLookup.set(0x1780, () => new MissingRequiredSignatureError());
createErrorFromNameLookup.set(
  'MissingRequiredSignature',
  () => new MissingRequiredSignatureError(),
);

/**
 * TokenBurnFailed: 'Token burn failed'
 *
 * @category Errors
 * @category generated
 */
export class TokenBurnFailedError extends Error {
  readonly code: number = 0x1781;
  readonly name: string = 'TokenBurnFailed';
  constructor() {
    super('Token burn failed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenBurnFailedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1781, () => new TokenBurnFailedError());
createErrorFromNameLookup.set('TokenBurnFailed', () => new TokenBurnFailedError());

/**
 * NoWhitelistToken: 'No whitelist token present'
 *
 * @category Errors
 * @category generated
 */
export class NoWhitelistTokenError extends Error {
  readonly code: number = 0x1782;
  readonly name: string = 'NoWhitelistToken';
  constructor() {
    super('No whitelist token present');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoWhitelistTokenError);
    }
  }
}

createErrorFromCodeLookup.set(0x1782, () => new NoWhitelistTokenError());
createErrorFromNameLookup.set('NoWhitelistToken', () => new NoWhitelistTokenError());

/**
 * GatewayTokenInvalid: 'Gateway token is not valid'
 *
 * @category Errors
 * @category generated
 */
export class GatewayTokenInvalidError extends Error {
  readonly code: number = 0x1783;
  readonly name: string = 'GatewayTokenInvalid';
  constructor() {
    super('Gateway token is not valid');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, GatewayTokenInvalidError);
    }
  }
}

createErrorFromCodeLookup.set(0x1783, () => new GatewayTokenInvalidError());
createErrorFromNameLookup.set('GatewayTokenInvalid', () => new GatewayTokenInvalidError());

/**
 * AfterEndSettingsDate: 'Current time is after the set end settings date'
 *
 * @category Errors
 * @category generated
 */
export class AfterEndSettingsDateError extends Error {
  readonly code: number = 0x1784;
  readonly name: string = 'AfterEndSettingsDate';
  constructor() {
    super('Current time is after the set end settings date');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AfterEndSettingsDateError);
    }
  }
}

createErrorFromCodeLookup.set(0x1784, () => new AfterEndSettingsDateError());
createErrorFromNameLookup.set('AfterEndSettingsDate', () => new AfterEndSettingsDateError());

/**
 * AfterEndSettingsMintAmount: 'Current items minted is at the set end settings amount'
 *
 * @category Errors
 * @category generated
 */
export class AfterEndSettingsMintAmountError extends Error {
  readonly code: number = 0x1785;
  readonly name: string = 'AfterEndSettingsMintAmount';
  constructor() {
    super('Current items minted is at the set end settings amount');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AfterEndSettingsMintAmountError);
    }
  }
}

createErrorFromCodeLookup.set(0x1785, () => new AfterEndSettingsMintAmountError());
createErrorFromNameLookup.set(
  'AfterEndSettingsMintAmount',
  () => new AfterEndSettingsMintAmountError(),
);

/**
 * InvalidMintTime: 'Current time is not within the allowed mint time'
 *
 * @category Errors
 * @category generated
 */
export class InvalidMintTimeError extends Error {
  readonly code: number = 0x1786;
  readonly name: string = 'InvalidMintTime';
  constructor() {
    super('Current time is not within the allowed mint time');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidMintTimeError);
    }
  }
}

createErrorFromCodeLookup.set(0x1786, () => new InvalidMintTimeError());
createErrorFromNameLookup.set('InvalidMintTime', () => new InvalidMintTimeError());

/**
 * AddressNotFoundInAllowedList: 'Address not found on the allowed list'
 *
 * @category Errors
 * @category generated
 */
export class AddressNotFoundInAllowedListError extends Error {
  readonly code: number = 0x1787;
  readonly name: string = 'AddressNotFoundInAllowedList';
  constructor() {
    super('Address not found on the allowed list');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AddressNotFoundInAllowedListError);
    }
  }
}

createErrorFromCodeLookup.set(0x1787, () => new AddressNotFoundInAllowedListError());
createErrorFromNameLookup.set(
  'AddressNotFoundInAllowedList',
  () => new AddressNotFoundInAllowedListError(),
);

/**
 * MissingAllowedListProof: 'Missing allowed list proof'
 *
 * @category Errors
 * @category generated
 */
export class MissingAllowedListProofError extends Error {
  readonly code: number = 0x1788;
  readonly name: string = 'MissingAllowedListProof';
  constructor() {
    super('Missing allowed list proof');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingAllowedListProofError);
    }
  }
}

createErrorFromCodeLookup.set(0x1788, () => new MissingAllowedListProofError());
createErrorFromNameLookup.set('MissingAllowedListProof', () => new MissingAllowedListProofError());

/**
 * AllowedMintLimitReached: 'The maximum number of allowed mints was reached'
 *
 * @category Errors
 * @category generated
 */
export class AllowedMintLimitReachedError extends Error {
  readonly code: number = 0x1789;
  readonly name: string = 'AllowedMintLimitReached';
  constructor() {
    super('The maximum number of allowed mints was reached');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AllowedMintLimitReachedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1789, () => new AllowedMintLimitReachedError());
createErrorFromNameLookup.set('AllowedMintLimitReached', () => new AllowedMintLimitReachedError());

/**
 * InvalidNFTCollectionPayment: 'Invalid NFT Collection Payment'
 *
 * @category Errors
 * @category generated
 */
export class InvalidNFTCollectionPaymentError extends Error {
  readonly code: number = 0x178a;
  readonly name: string = 'InvalidNFTCollectionPayment';
  constructor() {
    super('Invalid NFT Collection Payment');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidNFTCollectionPaymentError);
    }
  }
}

createErrorFromCodeLookup.set(0x178a, () => new InvalidNFTCollectionPaymentError());
createErrorFromNameLookup.set(
  'InvalidNFTCollectionPayment',
  () => new InvalidNFTCollectionPaymentError(),
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code);
  return createError != null ? createError() : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name);
  return createError != null ? createError() : null;
}
