pub mod context;

use anchor_lang::{self, AccountDeserialize, InstructionData, ToAccountMetas};
use bytemuck::{try_from_bytes, PodCastError};
use mpl_bubblegum::{
    hash_creators, hash_metadata,
    state::{metaplex_adapter::MetadataArgs, TreeConfig},
};
use solana_program::{
    instruction::Instruction, pubkey::Pubkey, rent::Rent, system_instruction, system_program,
};
use solana_program_test::{BanksClient, BanksClientError, ProgramTest};
use solana_sdk::{
    account::Account,
    instruction::AccountMeta,
    signature::{Keypair, Signer, SignerError},
    signer::signers::Signers,
    transaction::Transaction,
};
use spl_account_compression::state::ConcurrentMerkleTreeHeader;
use spl_concurrent_merkle_tree::concurrent_merkle_tree::ConcurrentMerkleTree;
use std::{
    cell::{RefCell, RefMut},
    convert::TryFrom,
    mem::size_of,
    result,
};

#[derive(Debug)]
pub enum Error {
    AccountNotFound(Pubkey),
    Anchor(anchor_lang::error::Error),
    BanksClient(BanksClientError),
    BytemuckPod(PodCastError),
    Signer(SignerError),
}

pub type Result<T> = result::Result<T, Error>;

pub fn program_test() -> ProgramTest {
    let mut test = ProgramTest::new("mpl_bubblegum", mpl_bubblegum::id(), None);
    test.add_program(
        "WRAPYChf58WFCnyjXKJHtrPgzKXgHp6MD9aVDqJBbGh",
        spl_noop::id(),
        None,
    );
    test.add_program(
        "GRoLLzvxpxxu2PGNJMMeZPyMxjAUH9pKqxGXV9DGiceU",
        spl_account_compression::id(),
        None,
    );
    test.set_compute_max_units(u64::MAX);
    test
}

fn instruction<T, U>(accounts: &T, data: &U) -> Instruction
where
    T: ToAccountMetas,
    U: InstructionData,
{
    Instruction {
        program_id: mpl_bubblegum::id(),
        accounts: accounts.to_account_metas(None),
        data: data.data(),
    }
}

// Helper method to copy keypairs for testing, since they don't implement
// `Copy/Clone` themselves (for some good reasons).
pub fn clone_keypair(k: &Keypair) -> Keypair {
    Keypair::from_bytes(k.to_bytes().as_slice()).unwrap()
}

// Computes the `data_hash` and `creator_hash`. Taken from the contract code where something
// similar is computed. Needs subsequent cleanup/refactoring.
fn compute_metadata_hashes(metadata_args: &MetadataArgs) -> Result<([u8; 32], [u8; 32])> {
    let data_hash = hash_metadata(metadata_args).map_err(Error::Anchor)?;
    let creator_hash = hash_creators(metadata_args.creators.as_slice()).map_err(Error::Anchor)?;
    Ok((data_hash, creator_hash))
}

// Helper object to execute and easily alter characteristics of transactions
// which contain a Bubblegum instruction. There's one instantiation for each
// particular operation (when T and U become concrete types), which are
// aliased a bit further below for convenience. The point of these objects
// is to be easy to set up for the common case of each operation, but at the
// same time easy to tweak via the pub fields and methods (including ones that
// can be added) such that it's easy to validate various test cases.
pub struct TxBuilder<T, U> {
    // This is the accounts structure that holds all the pubkeys, and for
    // each particular op we'll use the one generated by Anchor.
    //
    // TODO: IIRC some of the instructions use additional accounts for
    // some specific semantics; Add an option to specifiy those extra
    // accounts as well if necessary.
    pub accounts: T,
    pub additional_accounts: Vec<AccountMeta>,
    // Similar to the above, but for instruction data.
    pub data: U,
    // The currently configured payer for the tx.
    pub payer: Pubkey,
    // Using `RefCell` to provide interior mutability and circumvent some
    // annoyance with the borrow checker (i.e. provide helper methods that
    // only need &self, vs &mut self); if we'll ever need to use this
    // in a context with multiple threads, we can just replace the wrapper
    // with a `Mutex`.
    client: RefCell<BanksClient>,
    // Currently configured signers for the tx. Using only `Keypair`s as
    // signers for now; can make this more generic if needed.
    signers: Vec<Keypair>,
}

impl<T, U> TxBuilder<T, U>
where
    T: ToAccountMetas,
    U: InstructionData,
{
    fn client(&self) -> RefMut<BanksClient> {
        self.client.borrow_mut()
    }

    pub async fn execute(&self) -> Result<()> {
        let recent_blockhash = self
            .client()
            .get_latest_blockhash()
            .await
            .map_err(Error::BanksClient)?;

        let mut ix = instruction(&self.accounts, &self.data);

        // Add the additional accounts metas (if any) as well.
        ix.accounts.append(&mut self.additional_accounts.clone());

        let mut tx = Transaction::new_with_payer(&[ix], Some(&self.payer));

        // Using `try_partial_sign` to avoid panics (and get an error when something is
        // wrong instead) no matter what signers are configured.
        tx.try_partial_sign(&self.signers.iter().collect::<Vec<_>>(), recent_blockhash)
            .map_err(Error::Signer)?;

        self.client()
            .process_transaction(tx)
            .await
            .map_err(Error::BanksClient)
    }

    // Returning `&mut Self` to allow method chaining.
    pub fn set_signers(&mut self, signers: &[&Keypair]) -> &mut Self {
        self.signers = signers.iter().map(|k| clone_keypair(k)).collect();
        self
    }

    pub fn set_payer(&mut self, key: Pubkey) -> &mut Self {
        self.payer = key;
        self
    }

    pub fn set_additional_account_metas(&mut self, metas: &[AccountMeta]) -> &mut Self {
        self.additional_accounts = metas.iter().cloned().collect();
        self
    }

    // Populate the `additional_account` member with read-only and non-signer accounts based
    // on the provided public keys.
    pub fn set_additional_accounts(&mut self, keys: &[Pubkey]) -> &mut Self {
        self.additional_accounts = keys
            .iter()
            .map(|key| AccountMeta::new_readonly(*key, false))
            .collect();
        self
    }
}

// The types below have "builder" in their names because we're essentially
// implementing a lightweight builder patter to instantiate, customize, and
// execute transactions.
pub type CreateBuilder =
    TxBuilder<mpl_bubblegum::accounts::CreateTree, mpl_bubblegum::instruction::CreateTree>;

pub type MintV1Builder =
    TxBuilder<mpl_bubblegum::accounts::MintV1, mpl_bubblegum::instruction::MintV1>;

pub type BurnBuilder = TxBuilder<mpl_bubblegum::accounts::Burn, mpl_bubblegum::instruction::Burn>;

pub type TransferBuilder =
    TxBuilder<mpl_bubblegum::accounts::Transfer, mpl_bubblegum::instruction::Transfer>;

pub type DelegateBuilder =
    TxBuilder<mpl_bubblegum::accounts::Delegate, mpl_bubblegum::instruction::Delegate>;

pub type SetTreeDelegateBuilder = TxBuilder<
    mpl_bubblegum::accounts::SetTreeDelegate,
    mpl_bubblegum::instruction::SetTreeDelegate,
>;

pub type VerifyCreatorBuilder = TxBuilder<
    mpl_bubblegum::accounts::CreatorVerification,
    mpl_bubblegum::instruction::VerifyCreator,
>;

pub type UnverifyCreatorBuilder = TxBuilder<
    mpl_bubblegum::accounts::CreatorVerification,
    mpl_bubblegum::instruction::UnverifyCreator,
>;

pub struct LeafArgs {
    pub owner: Keypair,
    pub delegate: Keypair,
    pub metadata: MetadataArgs,
    pub nonce: u64,
    pub index: u32,
}

impl Clone for LeafArgs {
    fn clone(&self) -> Self {
        LeafArgs {
            owner: clone_keypair(&self.owner),
            delegate: clone_keypair(&self.delegate),
            metadata: self.metadata.clone(),
            nonce: self.nonce,
            index: self.index,
        }
    }
}

impl LeafArgs {
    // Creates a new object with some default values.
    pub fn new(owner: &Keypair, metadata: MetadataArgs) -> Self {
        LeafArgs {
            owner: clone_keypair(owner),
            delegate: clone_keypair(owner),
            metadata,
            nonce: 0,
            index: 0,
        }
    }
}

// A convenience object that records some of the parameters for compressed
// trees and generates TX builders with the default configuration for each
// operation.
// TODO: finish implementing all operations.
pub struct Tree<const MAX_DEPTH: usize, const MAX_BUFFER_SIZE: usize> {
    pub tree_creator: Keypair,
    pub tree_delegate: Keypair,
    pub merkle_tree: Keypair,
    pub canopy_depth: u32,
    client: RefCell<BanksClient>,
}

impl<const MAX_DEPTH: usize, const MAX_BUFFER_SIZE: usize> Tree<MAX_DEPTH, MAX_BUFFER_SIZE> {
    // This and `with_creator` use a bunch of defaults; things can be
    // customized some more via the public access, or we can add extra
    // methods to make things even easier.
    pub fn new(client: BanksClient) -> Self {
        Self::with_creator(&Keypair::new(), client)
    }

    pub fn with_creator(tree_creator: &Keypair, client: BanksClient) -> Self {
        Tree {
            tree_creator: clone_keypair(tree_creator),
            tree_delegate: clone_keypair(tree_creator),
            merkle_tree: Keypair::new(),
            canopy_depth: 0,
            client: RefCell::new(client),
        }
    }

    pub fn creator_pubkey(&self) -> Pubkey {
        self.tree_creator.pubkey()
    }

    pub fn delegate_pubkey(&self) -> Pubkey {
        self.tree_delegate.pubkey()
    }

    pub fn tree_pubkey(&self) -> Pubkey {
        self.merkle_tree.pubkey()
    }

    pub fn authority(&self) -> Pubkey {
        Pubkey::find_program_address(&[self.tree_pubkey().as_ref()], &mpl_bubblegum::id()).0
    }

    pub fn mint_authority_request(&self, authority: &Pubkey) -> Pubkey {
        Pubkey::find_program_address(
            &[self.tree_pubkey().as_ref(), authority.as_ref()],
            &mpl_bubblegum::id(),
        )
        .0
    }

    pub fn merkle_tree_account_size(&self) -> usize {
        size_of::<ConcurrentMerkleTreeHeader>()
            + size_of::<ConcurrentMerkleTree<MAX_DEPTH, MAX_BUFFER_SIZE>>()
    }

    pub fn client(&self) -> RefMut<BanksClient> {
        self.client.borrow_mut()
    }

    // Helper method to execute a transaction with the specified arguments
    // (i.e. single instruction) via the inner Banks client.
    pub async fn process_tx<T: Signers>(
        &self,
        instruction: Instruction,
        payer: &Pubkey,
        signing_keypairs: &T,
    ) -> Result<()> {
        let recent_blockhash = self
            .client()
            .get_latest_blockhash()
            .await
            .map_err(Error::BanksClient)?;

        self.client()
            .process_transaction(Transaction::new_signed_with_payer(
                &[instruction],
                Some(payer),
                signing_keypairs,
                recent_blockhash,
            ))
            .await
            .map_err(Error::BanksClient)
    }

    pub async fn rent(&self) -> Result<Rent> {
        self.client().get_rent().await.map_err(Error::BanksClient)
    }

    // Allocates and pays for an account to hold the tree.
    pub async fn alloc(&self, payer: &Keypair) -> Result<()> {
        let rent = self.rent().await?;
        let account_size = self.merkle_tree_account_size();

        // u64 -> usize conversion should never fail on the platforms we're running on.
        let lamports = rent.minimum_balance(usize::try_from(account_size).unwrap());

        let ix = system_instruction::create_account(
            &payer.pubkey(),
            &self.tree_pubkey(),
            lamports,
            // The `usize -> u64` conversion should never fail.
            u64::try_from(account_size).unwrap(),
            &spl_account_compression::id(),
        );

        self.process_tx(ix, &payer.pubkey(), &[payer, &self.merkle_tree])
            .await
    }

    // Helper fn to instantiate the various `TxBuilder` based concrete types
    // associated with each operation.
    fn tx_builder<T, U>(
        &self,
        accounts: T,
        data: U,
        payer: Pubkey,
        default_signers: &[&Keypair],
    ) -> TxBuilder<T, U> {
        let def_signers = default_signers.iter().map(|k| clone_keypair(k)).collect();

        TxBuilder {
            accounts,
            additional_accounts: Vec::new(),
            data,
            payer,
            client: self.client.clone(),
            signers: def_signers,
        }
    }

    // The `operation_tx` method instantiate a default builder object for a
    // transaction that can be used to execute that particular operation (tree
    // create in this case). The object can be modified (i.e. to use a
    // different signer, payer, accounts, data, etc.) before execution.
    // Moreover executions don't consume the builder, which can be modified
    // some more and executed again etc.
    pub fn create_tree_tx(&self, payer: &Keypair) -> CreateBuilder {
        let accounts = mpl_bubblegum::accounts::CreateTree {
            tree_authority: self.authority(),
            payer: payer.pubkey(),
            tree_creator: self.creator_pubkey(),
            log_wrapper: spl_noop::id(),
            system_program: system_program::id(),
            compression_program: spl_account_compression::id(),
            merkle_tree: self.tree_pubkey(),
        };

        // The conversions below should not fail.
        let data = mpl_bubblegum::instruction::CreateTree {
            max_depth: u32::try_from(MAX_DEPTH).unwrap(),
            max_buffer_size: u32::try_from(MAX_BUFFER_SIZE).unwrap(),
        };

        self.tx_builder(accounts, data, payer.pubkey(), &[payer])
    }

    // Shorthand method for executing a create tree tx with the default config
    // defined in the `_tx` method.
    pub async fn create(&self, payer: &Keypair) -> Result<()> {
        self.create_tree_tx(payer).execute().await
    }

    pub fn mint_v1_tx(&self, tree_delegate: &Keypair, args: &LeafArgs) -> MintV1Builder {
        let accounts = mpl_bubblegum::accounts::MintV1 {
            tree_authority: self.authority(),
            tree_delegate: tree_delegate.pubkey(),
            payer: args.owner.pubkey(),
            log_wrapper: spl_noop::id(),
            compression_program: spl_account_compression::id(),
            leaf_owner: args.owner.pubkey(),
            leaf_delegate: args.delegate.pubkey(),
            merkle_tree: self.tree_pubkey(),
        };

        let data = mpl_bubblegum::instruction::MintV1 {
            message: args.metadata.clone(),
        };

        self.tx_builder(
            accounts,
            data,
            args.owner.pubkey(),
            &[tree_delegate, &args.owner],
        )
    }

    // This assumes the owner is the account paying for the tx. We can make things
    // more configurable for any of the methods.
    pub async fn mint_v1(&self, tree_delegate: &Keypair, args: &LeafArgs) -> Result<()> {
        self.mint_v1_tx(tree_delegate, args).execute().await
    }

    pub async fn decode_root(&self) -> Result<[u8; 32]> {
        let mut tree_account = self.read_account(self.tree_pubkey()).await?;

        let merkle_tree_bytes = tree_account.data.as_mut_slice();
        let (_header_bytes, rest) =
            merkle_tree_bytes.split_at_mut(size_of::<ConcurrentMerkleTreeHeader>());

        let merkle_tree_size = size_of::<ConcurrentMerkleTree<MAX_DEPTH, MAX_BUFFER_SIZE>>();
        let tree_bytes = &mut rest[..merkle_tree_size];

        let tree = try_from_bytes::<ConcurrentMerkleTree<MAX_DEPTH, MAX_BUFFER_SIZE>>(tree_bytes)
            .map_err(Error::BytemuckPod)?;
        let root = tree.change_logs[tree.active_index as usize].root;

        Ok(root)
    }

    // This is currently async due to calling `decode_root` (same goes for a bunch of others).
    pub async fn burn_tx(&self, args: &LeafArgs) -> Result<BurnBuilder> {
        let root = self.decode_root().await?;

        let (data_hash, creator_hash) = compute_metadata_hashes(&args.metadata)?;

        let accounts = mpl_bubblegum::accounts::Burn {
            tree_authority: self.authority(),
            log_wrapper: spl_noop::id(),
            compression_program: spl_account_compression::id(),
            leaf_owner: args.owner.pubkey(),
            leaf_delegate: args.delegate.pubkey(),
            merkle_tree: self.tree_pubkey(),
        };

        let data = mpl_bubblegum::instruction::Burn {
            root,
            data_hash,
            creator_hash,
            nonce: args.nonce,
            index: args.index,
        };

        Ok(self.tx_builder(accounts, data, args.owner.pubkey(), &[&args.owner]))
    }

    pub async fn burn(&self, args: &LeafArgs) -> Result<()> {
        self.burn_tx(args).await?.execute().await
    }

    pub async fn verify_creator_tx(
        &self,
        args: &LeafArgs,
        creator: &Keypair,
    ) -> Result<VerifyCreatorBuilder> {
        let root = self.decode_root().await?;
        let (data_hash, creator_hash) = compute_metadata_hashes(&args.metadata)?;

        let accounts = mpl_bubblegum::accounts::CreatorVerification {
            tree_authority: self.authority(),
            leaf_owner: args.owner.pubkey(),
            leaf_delegate: args.delegate.pubkey(),
            payer: creator.pubkey(),
            creator: creator.pubkey(),
            log_wrapper: spl_noop::id(),
            compression_program: spl_account_compression::id(),
            merkle_tree: self.tree_pubkey(),
        };

        let data = mpl_bubblegum::instruction::VerifyCreator {
            root,
            data_hash,
            creator_hash,
            nonce: args.nonce,
            index: args.index,
            message: args.metadata.clone(),
        };

        Ok(self.tx_builder(accounts, data, creator.pubkey(), &[creator]))
    }

    pub async fn verify_creator(&self, args: &LeafArgs, creator: &Keypair) -> Result<()> {
        self.verify_creator_tx(args, creator).await?.execute().await
    }

    pub async fn unverify_creator_tx(
        &self,
        args: &LeafArgs,
        creator: &Keypair,
    ) -> Result<UnverifyCreatorBuilder> {
        let root = self.decode_root().await?;
        let (data_hash, creator_hash) = compute_metadata_hashes(&args.metadata)?;

        let accounts = mpl_bubblegum::accounts::CreatorVerification {
            tree_authority: self.authority(),
            leaf_owner: args.owner.pubkey(),
            leaf_delegate: args.delegate.pubkey(),
            payer: creator.pubkey(),
            creator: creator.pubkey(),
            log_wrapper: spl_noop::id(),
            compression_program: spl_account_compression::id(),
            merkle_tree: self.tree_pubkey(),
        };

        let data = mpl_bubblegum::instruction::UnverifyCreator {
            root,
            data_hash,
            creator_hash,
            nonce: args.nonce,
            index: args.index,
            message: args.metadata.clone(),
        };

        Ok(self.tx_builder(accounts, data, creator.pubkey(), &[creator]))
    }

    pub async fn unverify_creator(&self, args: &LeafArgs, creator: &Keypair) -> Result<()> {
        self.unverify_creator_tx(args, creator)
            .await?
            .execute()
            .await
    }

    pub async fn transfer_tx(
        &self,
        args: &LeafArgs,
        new_leaf_owner: Pubkey,
    ) -> Result<TransferBuilder> {
        let root = self.decode_root().await?;
        let (data_hash, creator_hash) = compute_metadata_hashes(&args.metadata)?;

        let accounts = mpl_bubblegum::accounts::Transfer {
            tree_authority: self.authority(),
            leaf_owner: args.owner.pubkey(),
            leaf_delegate: args.delegate.pubkey(),
            new_leaf_owner,
            log_wrapper: spl_noop::id(),
            compression_program: spl_account_compression::id(),
            merkle_tree: self.tree_pubkey(),
        };

        let data = mpl_bubblegum::instruction::Transfer {
            root,
            data_hash,
            creator_hash,
            nonce: args.nonce,
            index: args.index,
        };

        Ok(self.tx_builder(accounts, data, args.owner.pubkey(), &[&args.owner]))
    }

    pub async fn transfer(&self, args: &LeafArgs, new_owner: Pubkey) -> Result<()> {
        self.transfer_tx(args, new_owner).await?.execute().await
    }

    pub async fn delegate_tx(
        &self,
        args: &LeafArgs,
        new_leaf_delegate: Pubkey,
    ) -> Result<DelegateBuilder> {
        let root = self.decode_root().await?;
        let (data_hash, creator_hash) = compute_metadata_hashes(&args.metadata)?;

        let accounts = mpl_bubblegum::accounts::Delegate {
            tree_authority: self.authority(),
            leaf_owner: args.owner.pubkey(),
            previous_leaf_delegate: args.delegate.pubkey(),
            new_leaf_delegate,
            log_wrapper: spl_noop::id(),
            compression_program: spl_account_compression::id(),
            merkle_tree: self.tree_pubkey(),
        };

        let data = mpl_bubblegum::instruction::Delegate {
            root,
            data_hash,
            creator_hash,
            nonce: args.nonce,
            index: args.index,
        };

        Ok(self.tx_builder(accounts, data, args.owner.pubkey(), &[&args.owner]))
    }

    // Does the prev delegate need to sign as well?
    pub async fn delegate(&self, args: &LeafArgs, new_delegate: Pubkey) -> Result<()> {
        self.delegate_tx(args, new_delegate).await?.execute().await
    }

    pub fn set_tree_delegate_tx(&self, new_tree_delegate: Pubkey) -> SetTreeDelegateBuilder {
        let accounts = mpl_bubblegum::accounts::SetTreeDelegate {
            tree_creator: self.creator_pubkey(),
            new_tree_delegate,
            merkle_tree: self.tree_pubkey(),
            tree_authority: self.authority(),
        };

        let data = mpl_bubblegum::instruction::SetTreeDelegate;

        self.tx_builder(accounts, data, self.creator_pubkey(), &[&self.tree_creator])
    }

    pub async fn set_tree_delegate(&mut self, new_delegate: &Keypair) -> Result<()> {
        self.set_tree_delegate_tx(new_delegate.pubkey())
            .execute()
            .await?;
        self.tree_delegate = clone_keypair(new_delegate);
        Ok(())
    }

    // The following methods provide convenience when reading data from accounts.
    async fn read_account(&self, key: Pubkey) -> Result<Account> {
        self.client()
            .get_account(key)
            .await
            .map_err(Error::BanksClient)?
            .ok_or(Error::AccountNotFound(key))
    }

    // This reads the `Account`, but also deserializes the data to return
    // the strongly typed inner contents.
    pub async fn read_account_data<T>(&self, key: Pubkey) -> Result<T>
    where
        T: AccountDeserialize,
    {
        self.read_account(key)
            .await
            .and_then(|acc| T::try_deserialize(&mut acc.data.as_slice()).map_err(Error::Anchor))
    }

    pub async fn read_tree_config(&self) -> Result<TreeConfig> {
        self.read_account_data(self.authority()).await
    }
}
