/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number };
type MaybeErrorWithCode = ErrorWithCode | null | undefined;

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map();
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map();

/**
 * WrongAllowedAmountToRedeem: 'Allowed amount to redeem should be more then 0'
 *
 * @category Errors
 * @category generated
 */
export class WrongAllowedAmountToRedeemError extends Error {
  readonly code: number = 0x0;
  readonly name: string = 'WrongAllowedAmountToRedeem';
  constructor() {
    super('Allowed amount to redeem should be more then 0');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongAllowedAmountToRedeemError);
    }
  }
}

createErrorFromCodeLookup.set(0x0, () => new WrongAllowedAmountToRedeemError());
createErrorFromNameLookup.set(
  'WrongAllowedAmountToRedeem',
  () => new WrongAllowedAmountToRedeemError(),
);

/**
 * WrongRedeemDate: 'Wrong redeem date'
 *
 * @category Errors
 * @category generated
 */
export class WrongRedeemDateError extends Error {
  readonly code: number = 0x1;
  readonly name: string = 'WrongRedeemDate';
  constructor() {
    super('Wrong redeem date');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongRedeemDateError);
    }
  }
}

createErrorFromCodeLookup.set(0x1, () => new WrongRedeemDateError());
createErrorFromNameLookup.set('WrongRedeemDate', () => new WrongRedeemDateError());

/**
 * CardProbabilityMissing: 'Card probability is missing'
 *
 * @category Errors
 * @category generated
 */
export class CardProbabilityMissingError extends Error {
  readonly code: number = 0x2;
  readonly name: string = 'CardProbabilityMissing';
  constructor() {
    super('Card probability is missing');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CardProbabilityMissingError);
    }
  }
}

createErrorFromCodeLookup.set(0x2, () => new CardProbabilityMissingError());
createErrorFromNameLookup.set('CardProbabilityMissing', () => new CardProbabilityMissingError());

/**
 * WrongCardProbability: 'Wrong card probability value'
 *
 * @category Errors
 * @category generated
 */
export class WrongCardProbabilityError extends Error {
  readonly code: number = 0x3;
  readonly name: string = 'WrongCardProbability';
  constructor() {
    super('Wrong card probability value');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongCardProbabilityError);
    }
  }
}

createErrorFromCodeLookup.set(0x3, () => new WrongCardProbabilityError());
createErrorFromNameLookup.set('WrongCardProbability', () => new WrongCardProbabilityError());

/**
 * CardShouldntHaveProbabilityValue: 'Cards for this pack shouldn't have probability value'
 *
 * @category Errors
 * @category generated
 */
export class CardShouldntHaveProbabilityValueError extends Error {
  readonly code: number = 0x4;
  readonly name: string = 'CardShouldntHaveProbabilityValue';
  constructor() {
    super("Cards for this pack shouldn't have probability value");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CardShouldntHaveProbabilityValueError);
    }
  }
}

createErrorFromCodeLookup.set(0x4, () => new CardShouldntHaveProbabilityValueError());
createErrorFromNameLookup.set(
  'CardShouldntHaveProbabilityValue',
  () => new CardShouldntHaveProbabilityValueError(),
);

/**
 * ProvedVouchersMismatchPackVouchers: 'Proved vouchers mismatch pack vouchers'
 *
 * @category Errors
 * @category generated
 */
export class ProvedVouchersMismatchPackVouchersError extends Error {
  readonly code: number = 0x5;
  readonly name: string = 'ProvedVouchersMismatchPackVouchers';
  constructor() {
    super('Proved vouchers mismatch pack vouchers');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ProvedVouchersMismatchPackVouchersError);
    }
  }
}

createErrorFromCodeLookup.set(0x5, () => new ProvedVouchersMismatchPackVouchersError());
createErrorFromNameLookup.set(
  'ProvedVouchersMismatchPackVouchers',
  () => new ProvedVouchersMismatchPackVouchersError(),
);

/**
 * PackIsAlreadyEnded: 'Pack is already ended'
 *
 * @category Errors
 * @category generated
 */
export class PackIsAlreadyEndedError extends Error {
  readonly code: number = 0x6;
  readonly name: string = 'PackIsAlreadyEnded';
  constructor() {
    super('Pack is already ended');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PackIsAlreadyEndedError);
    }
  }
}

createErrorFromCodeLookup.set(0x6, () => new PackIsAlreadyEndedError());
createErrorFromNameLookup.set('PackIsAlreadyEnded', () => new PackIsAlreadyEndedError());

/**
 * PackSetNotConfigured: 'NFT pack set not fully configured'
 *
 * @category Errors
 * @category generated
 */
export class PackSetNotConfiguredError extends Error {
  readonly code: number = 0x7;
  readonly name: string = 'PackSetNotConfigured';
  constructor() {
    super('NFT pack set not fully configured');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PackSetNotConfiguredError);
    }
  }
}

createErrorFromCodeLookup.set(0x7, () => new PackSetNotConfiguredError());
createErrorFromNameLookup.set('PackSetNotConfigured', () => new PackSetNotConfiguredError());

/**
 * CantActivatePack: 'Can't activate NFT pack in current state'
 *
 * @category Errors
 * @category generated
 */
export class CantActivatePackError extends Error {
  readonly code: number = 0x8;
  readonly name: string = 'CantActivatePack';
  constructor() {
    super("Can't activate NFT pack in current state");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CantActivatePackError);
    }
  }
}

createErrorFromCodeLookup.set(0x8, () => new CantActivatePackError());
createErrorFromNameLookup.set('CantActivatePack', () => new CantActivatePackError());

/**
 * PackSetNotActivated: 'Pack set should be activated'
 *
 * @category Errors
 * @category generated
 */
export class PackSetNotActivatedError extends Error {
  readonly code: number = 0x9;
  readonly name: string = 'PackSetNotActivated';
  constructor() {
    super('Pack set should be activated');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PackSetNotActivatedError);
    }
  }
}

createErrorFromCodeLookup.set(0x9, () => new PackSetNotActivatedError());
createErrorFromNameLookup.set('PackSetNotActivated', () => new PackSetNotActivatedError());

/**
 * ProvingPackProcessCompleted: 'Proving process for this pack is completed'
 *
 * @category Errors
 * @category generated
 */
export class ProvingPackProcessCompletedError extends Error {
  readonly code: number = 0xa;
  readonly name: string = 'ProvingPackProcessCompleted';
  constructor() {
    super('Proving process for this pack is completed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ProvingPackProcessCompletedError);
    }
  }
}

createErrorFromCodeLookup.set(0xa, () => new ProvingPackProcessCompletedError());
createErrorFromNameLookup.set(
  'ProvingPackProcessCompleted',
  () => new ProvingPackProcessCompletedError(),
);

/**
 * ProvingVoucherProcessCompleted: 'Proving process for this voucher is completed'
 *
 * @category Errors
 * @category generated
 */
export class ProvingVoucherProcessCompletedError extends Error {
  readonly code: number = 0xb;
  readonly name: string = 'ProvingVoucherProcessCompleted';
  constructor() {
    super('Proving process for this voucher is completed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ProvingVoucherProcessCompletedError);
    }
  }
}

createErrorFromCodeLookup.set(0xb, () => new ProvingVoucherProcessCompletedError());
createErrorFromNameLookup.set(
  'ProvingVoucherProcessCompleted',
  () => new ProvingVoucherProcessCompletedError(),
);

/**
 * WrongEdition: 'Received edition from wrong master'
 *
 * @category Errors
 * @category generated
 */
export class WrongEditionError extends Error {
  readonly code: number = 0xc;
  readonly name: string = 'WrongEdition';
  constructor() {
    super('Received edition from wrong master');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongEditionError);
    }
  }
}

createErrorFromCodeLookup.set(0xc, () => new WrongEditionError());
createErrorFromNameLookup.set('WrongEdition', () => new WrongEditionError());

/**
 * WrongEditionMint: 'Received wrong edition mint'
 *
 * @category Errors
 * @category generated
 */
export class WrongEditionMintError extends Error {
  readonly code: number = 0xd;
  readonly name: string = 'WrongEditionMint';
  constructor() {
    super('Received wrong edition mint');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongEditionMintError);
    }
  }
}

createErrorFromCodeLookup.set(0xd, () => new WrongEditionMintError());
createErrorFromNameLookup.set('WrongEditionMint', () => new WrongEditionMintError());

/**
 * Overflow: 'Overflow'
 *
 * @category Errors
 * @category generated
 */
export class OverflowError extends Error {
  readonly code: number = 0xe;
  readonly name: string = 'Overflow';
  constructor() {
    super('Overflow');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OverflowError);
    }
  }
}

createErrorFromCodeLookup.set(0xe, () => new OverflowError());
createErrorFromNameLookup.set('Overflow', () => new OverflowError());

/**
 * Underflow: 'Underflow'
 *
 * @category Errors
 * @category generated
 */
export class UnderflowError extends Error {
  readonly code: number = 0xf;
  readonly name: string = 'Underflow';
  constructor() {
    super('Underflow');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnderflowError);
    }
  }
}

createErrorFromCodeLookup.set(0xf, () => new UnderflowError());
createErrorFromNameLookup.set('Underflow', () => new UnderflowError());

/**
 * NotEmptyPackSet: 'Pack set should be empty to delete it'
 *
 * @category Errors
 * @category generated
 */
export class NotEmptyPackSetError extends Error {
  readonly code: number = 0x10;
  readonly name: string = 'NotEmptyPackSet';
  constructor() {
    super('Pack set should be empty to delete it');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotEmptyPackSetError);
    }
  }
}

createErrorFromCodeLookup.set(0x10, () => new NotEmptyPackSetError());
createErrorFromNameLookup.set('NotEmptyPackSet', () => new NotEmptyPackSetError());

/**
 * WrongPackState: 'Wrong pack state to change data'
 *
 * @category Errors
 * @category generated
 */
export class WrongPackStateError extends Error {
  readonly code: number = 0x11;
  readonly name: string = 'WrongPackState';
  constructor() {
    super('Wrong pack state to change data');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongPackStateError);
    }
  }
}

createErrorFromCodeLookup.set(0x11, () => new WrongPackStateError());
createErrorFromNameLookup.set('WrongPackState', () => new WrongPackStateError());

/**
 * ImmutablePackSet: 'Pack set is immutable'
 *
 * @category Errors
 * @category generated
 */
export class ImmutablePackSetError extends Error {
  readonly code: number = 0x12;
  readonly name: string = 'ImmutablePackSet';
  constructor() {
    super('Pack set is immutable');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ImmutablePackSetError);
    }
  }
}

createErrorFromCodeLookup.set(0x12, () => new ImmutablePackSetError());
createErrorFromNameLookup.set('ImmutablePackSet', () => new ImmutablePackSetError());

/**
 * CantSetTheSameValue: 'Can't set the same value'
 *
 * @category Errors
 * @category generated
 */
export class CantSetTheSameValueError extends Error {
  readonly code: number = 0x13;
  readonly name: string = 'CantSetTheSameValue';
  constructor() {
    super("Can't set the same value");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CantSetTheSameValueError);
    }
  }
}

createErrorFromCodeLookup.set(0x13, () => new CantSetTheSameValueError());
createErrorFromNameLookup.set('CantSetTheSameValue', () => new CantSetTheSameValueError());

/**
 * WrongMaxSupply: 'Wrong max supply value'
 *
 * @category Errors
 * @category generated
 */
export class WrongMaxSupplyError extends Error {
  readonly code: number = 0x14;
  readonly name: string = 'WrongMaxSupply';
  constructor() {
    super('Wrong max supply value');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongMaxSupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x14, () => new WrongMaxSupplyError());
createErrorFromNameLookup.set('WrongMaxSupply', () => new WrongMaxSupplyError());

/**
 * WrongVoucherSupply: 'Voucher should have supply greater then 0'
 *
 * @category Errors
 * @category generated
 */
export class WrongVoucherSupplyError extends Error {
  readonly code: number = 0x15;
  readonly name: string = 'WrongVoucherSupply';
  constructor() {
    super('Voucher should have supply greater then 0');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongVoucherSupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x15, () => new WrongVoucherSupplyError());
createErrorFromNameLookup.set('WrongVoucherSupply', () => new WrongVoucherSupplyError());

/**
 * CardDoesntHaveEditions: 'Card ran out of editions'
 *
 * @category Errors
 * @category generated
 */
export class CardDoesntHaveEditionsError extends Error {
  readonly code: number = 0x16;
  readonly name: string = 'CardDoesntHaveEditions';
  constructor() {
    super('Card ran out of editions');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CardDoesntHaveEditionsError);
    }
  }
}

createErrorFromCodeLookup.set(0x16, () => new CardDoesntHaveEditionsError());
createErrorFromNameLookup.set('CardDoesntHaveEditions', () => new CardDoesntHaveEditionsError());

/**
 * UserRedeemedAllCards: 'User redeemed all allowed cards'
 *
 * @category Errors
 * @category generated
 */
export class UserRedeemedAllCardsError extends Error {
  readonly code: number = 0x17;
  readonly name: string = 'UserRedeemedAllCards';
  constructor() {
    super('User redeemed all allowed cards');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UserRedeemedAllCardsError);
    }
  }
}

createErrorFromCodeLookup.set(0x17, () => new UserRedeemedAllCardsError());
createErrorFromNameLookup.set('UserRedeemedAllCards', () => new UserRedeemedAllCardsError());

/**
 * UriTooLong: 'URI too long'
 *
 * @category Errors
 * @category generated
 */
export class UriTooLongError extends Error {
  readonly code: number = 0x18;
  readonly name: string = 'UriTooLong';
  constructor() {
    super('URI too long');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UriTooLongError);
    }
  }
}

createErrorFromCodeLookup.set(0x18, () => new UriTooLongError());
createErrorFromNameLookup.set('UriTooLong', () => new UriTooLongError());

/**
 * CardDoesntHaveMaxSupply: 'Card doesn't have max supply'
 *
 * @category Errors
 * @category generated
 */
export class CardDoesntHaveMaxSupplyError extends Error {
  readonly code: number = 0x19;
  readonly name: string = 'CardDoesntHaveMaxSupply';
  constructor() {
    super("Card doesn't have max supply");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CardDoesntHaveMaxSupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x19, () => new CardDoesntHaveMaxSupplyError());
createErrorFromNameLookup.set('CardDoesntHaveMaxSupply', () => new CardDoesntHaveMaxSupplyError());

/**
 * WrongMasterSupply: 'Master edition should have unlimited supply'
 *
 * @category Errors
 * @category generated
 */
export class WrongMasterSupplyError extends Error {
  readonly code: number = 0x1a;
  readonly name: string = 'WrongMasterSupply';
  constructor() {
    super('Master edition should have unlimited supply');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongMasterSupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x1a, () => new WrongMasterSupplyError());
createErrorFromNameLookup.set('WrongMasterSupply', () => new WrongMasterSupplyError());

/**
 * MissingEditionsInPack: 'Pack set doesn't have total editions'
 *
 * @category Errors
 * @category generated
 */
export class MissingEditionsInPackError extends Error {
  readonly code: number = 0x1b;
  readonly name: string = 'MissingEditionsInPack';
  constructor() {
    super("Pack set doesn't have total editions");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingEditionsInPackError);
    }
  }
}

createErrorFromCodeLookup.set(0x1b, () => new MissingEditionsInPackError());
createErrorFromNameLookup.set('MissingEditionsInPack', () => new MissingEditionsInPackError());

/**
 * AlreadySetNextCardToRedeem: 'User already got next card to redeem'
 *
 * @category Errors
 * @category generated
 */
export class AlreadySetNextCardToRedeemError extends Error {
  readonly code: number = 0x1c;
  readonly name: string = 'AlreadySetNextCardToRedeem';
  constructor() {
    super('User already got next card to redeem');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AlreadySetNextCardToRedeemError);
    }
  }
}

createErrorFromCodeLookup.set(0x1c, () => new AlreadySetNextCardToRedeemError());
createErrorFromNameLookup.set(
  'AlreadySetNextCardToRedeem',
  () => new AlreadySetNextCardToRedeemError(),
);

/**
 * EndDateNotArrived: 'Can't close the pack before end date'
 *
 * @category Errors
 * @category generated
 */
export class EndDateNotArrivedError extends Error {
  readonly code: number = 0x1d;
  readonly name: string = 'EndDateNotArrived';
  constructor() {
    super("Can't close the pack before end date");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, EndDateNotArrivedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1d, () => new EndDateNotArrivedError());
createErrorFromNameLookup.set('EndDateNotArrived', () => new EndDateNotArrivedError());

/**
 * DescriptionTooLong: 'Pack description too long'
 *
 * @category Errors
 * @category generated
 */
export class DescriptionTooLongError extends Error {
  readonly code: number = 0x1e;
  readonly name: string = 'DescriptionTooLong';
  constructor() {
    super('Pack description too long');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DescriptionTooLongError);
    }
  }
}

createErrorFromCodeLookup.set(0x1e, () => new DescriptionTooLongError());
createErrorFromNameLookup.set('DescriptionTooLong', () => new DescriptionTooLongError());

/**
 * WhitelistedCreatorInactive: 'Whitelisted creator inactive'
 *
 * @category Errors
 * @category generated
 */
export class WhitelistedCreatorInactiveError extends Error {
  readonly code: number = 0x1f;
  readonly name: string = 'WhitelistedCreatorInactive';
  constructor() {
    super('Whitelisted creator inactive');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WhitelistedCreatorInactiveError);
    }
  }
}

createErrorFromCodeLookup.set(0x1f, () => new WhitelistedCreatorInactiveError());
createErrorFromNameLookup.set(
  'WhitelistedCreatorInactive',
  () => new WhitelistedCreatorInactiveError(),
);

/**
 * WrongWhitelistedCreator: 'Wrong whitelisted creator address'
 *
 * @category Errors
 * @category generated
 */
export class WrongWhitelistedCreatorError extends Error {
  readonly code: number = 0x20;
  readonly name: string = 'WrongWhitelistedCreator';
  constructor() {
    super('Wrong whitelisted creator address');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongWhitelistedCreatorError);
    }
  }
}

createErrorFromCodeLookup.set(0x20, () => new WrongWhitelistedCreatorError());
createErrorFromNameLookup.set('WrongWhitelistedCreator', () => new WrongWhitelistedCreatorError());

/**
 * WrongVoucherOwner: 'Voucher owner mismatch'
 *
 * @category Errors
 * @category generated
 */
export class WrongVoucherOwnerError extends Error {
  readonly code: number = 0x21;
  readonly name: string = 'WrongVoucherOwner';
  constructor() {
    super('Voucher owner mismatch');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WrongVoucherOwnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x21, () => new WrongVoucherOwnerError());
createErrorFromNameLookup.set('WrongVoucherOwner', () => new WrongVoucherOwnerError());

/**
 * CardShouldntHaveSupplyValue: 'Cards for this pack shouldn't have supply value'
 *
 * @category Errors
 * @category generated
 */
export class CardShouldntHaveSupplyValueError extends Error {
  readonly code: number = 0x22;
  readonly name: string = 'CardShouldntHaveSupplyValue';
  constructor() {
    super("Cards for this pack shouldn't have supply value");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CardShouldntHaveSupplyValueError);
    }
  }
}

createErrorFromCodeLookup.set(0x22, () => new CardShouldntHaveSupplyValueError());
createErrorFromNameLookup.set(
  'CardShouldntHaveSupplyValue',
  () => new CardShouldntHaveSupplyValueError(),
);

/**
 * PackIsFullWithCards: 'Pack is already full of cards'
 *
 * @category Errors
 * @category generated
 */
export class PackIsFullWithCardsError extends Error {
  readonly code: number = 0x23;
  readonly name: string = 'PackIsFullWithCards';
  constructor() {
    super('Pack is already full of cards');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PackIsFullWithCardsError);
    }
  }
}

createErrorFromCodeLookup.set(0x23, () => new PackIsFullWithCardsError());
createErrorFromNameLookup.set('PackIsFullWithCards', () => new PackIsFullWithCardsError());

/**
 * WeightsNotCleanedUp: 'Card weights should be cleaned up'
 *
 * @category Errors
 * @category generated
 */
export class WeightsNotCleanedUpError extends Error {
  readonly code: number = 0x24;
  readonly name: string = 'WeightsNotCleanedUp';
  constructor() {
    super('Card weights should be cleaned up');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, WeightsNotCleanedUpError);
    }
  }
}

createErrorFromCodeLookup.set(0x24, () => new WeightsNotCleanedUpError());
createErrorFromNameLookup.set('WeightsNotCleanedUp', () => new WeightsNotCleanedUpError());

/**
 * CardAlreadyRedeemed: 'User already redeemed this card'
 *
 * @category Errors
 * @category generated
 */
export class CardAlreadyRedeemedError extends Error {
  readonly code: number = 0x25;
  readonly name: string = 'CardAlreadyRedeemed';
  constructor() {
    super('User already redeemed this card');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CardAlreadyRedeemedError);
    }
  }
}

createErrorFromCodeLookup.set(0x25, () => new CardAlreadyRedeemedError());
createErrorFromNameLookup.set('CardAlreadyRedeemed', () => new CardAlreadyRedeemedError());

/**
 * UserCantRedeemThisCard: 'User can't redeem this card'
 *
 * @category Errors
 * @category generated
 */
export class UserCantRedeemThisCardError extends Error {
  readonly code: number = 0x26;
  readonly name: string = 'UserCantRedeemThisCard';
  constructor() {
    super("User can't redeem this card");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UserCantRedeemThisCardError);
    }
  }
}

createErrorFromCodeLookup.set(0x26, () => new UserCantRedeemThisCardError());
createErrorFromNameLookup.set('UserCantRedeemThisCard', () => new UserCantRedeemThisCardError());

/**
 * InvalidWeightPosition: 'Invalid weight position'
 *
 * @category Errors
 * @category generated
 */
export class InvalidWeightPositionError extends Error {
  readonly code: number = 0x27;
  readonly name: string = 'InvalidWeightPosition';
  constructor() {
    super('Invalid weight position');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidWeightPositionError);
    }
  }
}

createErrorFromCodeLookup.set(0x27, () => new InvalidWeightPositionError());
createErrorFromNameLookup.set('InvalidWeightPosition', () => new InvalidWeightPositionError());

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code);
  return createError != null ? createError() : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name);
  return createError != null ? createError() : null;
}
